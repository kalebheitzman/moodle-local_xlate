{"version":3,"file":"translator.min.js","sources":["../src/translator.js"],"sourcesContent":["// Local/xlate/amd/src/translator.js\n// Handles DOM translation and automatic key capture with structural-based keys.\n//\n// WORKFLOW:\n// 1. Tag element with data-xlate-key-{type} FIRST (always)\n// 2. If currentLang === siteLang: Save to DB (capture mode)\n// 3. If currentLang !== siteLang: Translate using bundle\n/**\n * AMD module that detects, captures, and renders Local Xlate translations.\n *\n * Responsibilities:\n *  - Capture mode: tag DOM nodes, check existing bundle entries, persist newly\n *    discovered strings, and link keys to the active course when permitted.\n *  - Translation mode: tag DOM nodes, request a filtered bundle, apply\n *    translations, and track subsequent DOM mutations to keep content synced.\n */\ndefine(['core/ajax'], function (Ajax) {\n  var ATTR_KEY_PREFIX = 'data-xlate-key-';\n  var ATTRIBUTE_TYPES = [\n    'placeholder', 'title', 'alt', 'aria-label'\n  ];\n\n  // Auto-detection is always enabled; keys are always auto-assigned.\n  var detectedStrings = new Set();\n  var processedElements = new WeakSet();\n  var lastProcessTime = 0;\n  var processThrottle = 250;\n  var pendingTranslationKeys = new Set();\n  var requestedTranslationKeys = new Set();\n  var missingFetchTimer = null;\n  /* Translator namespace to expose public API while keeping internal helpers private. */\n  var Translator = {};\n  Translator.utils = {};\n  Translator.keys = {};\n  Translator.attrs = {};\n  Translator.capture = {};\n  Translator.dom = {};\n  Translator.api = {};\n\n  /**\n   * Wrapper for debug logging which only emits when server-side debug is enabled.\n   * The hook in PHP will expose `window.XLATE_DEBUG` as true when Moodle debugging\n   * is set to DEVELOPER. This keeps noisy logs out of production.\n   */\n  /* eslint-disable no-console */\n  /**\n   * Debug logging helper. Emits messages only when `window.XLATE_DEBUG` is truthy.\n   * @returns {void}\n   */\n  function xlateDebug() {\n    if (typeof window !== 'undefined' && window.XLATE_DEBUG) {\n      if (typeof console !== 'undefined' && typeof console.debug === 'function') {\n        console.debug.apply(console, arguments);\n      } else if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  }\n  /* eslint-enable no-console */\n\n  // ============================================================================\n  // KEY GENERATION - Create structural 12-character hash keys\n  // ============================================================================\n\n  /**\n   * Collect meaningful class names from element\n   * @param {Element} element - The element to collect classes from\n   * @returns {string} Comma-separated class names\n   */\n  function collectContextClasses(element) {\n    if (!element || !element.classList) {\n      return '';\n    }\n\n    var blacklist = [\n      'active', 'show', 'hide', 'hidden', 'collapsed', 'expanded',\n      'd-flex', 'd-none', 'd-block', 'sr-only', 'visually-hidden'\n    ];\n\n    var classes = [];\n    Array.prototype.forEach.call(element.classList, function (cls) {\n      if (cls && cls.length > 2 && blacklist.indexOf(cls) === -1 &&\n        !/^[0-9]/.test(cls) && !/^[mp][tblr]?-[0-5]$/.test(cls)) {\n        classes.push(cls);\n      }\n    });\n\n    return classes.join(',');\n  }\n\n  /**\n   * Collect all data-* attributes from element (excluding data-xlate- attributes).\n   * @param {Element} element - The element to collect attributes from\n   * @returns {string} Comma-separated attribute values\n   */\n  function collectDataAttributes(element) {\n    if (!element || !element.attributes) {\n      return '';\n    }\n\n    var dataAttrs = [];\n    for (var i = 0; i < element.attributes.length; i++) {\n      var attr = element.attributes[i];\n      if (attr.name.indexOf('data-') === 0 && attr.name.indexOf('data-xlate') !== 0 && attr.value) {\n        dataAttrs.push(attr.value);\n      }\n    }\n    return dataAttrs.join(',');\n  }\n  Translator.utils.collectContextClasses = collectContextClasses;\n  Translator.utils.collectDataAttributes = collectDataAttributes;\n\n  /**\n   * Simple deterministic 12-char hash using two 32-bit accumulators (FNV-1a style + mix)\n   * Avoids constant zero padding by combining two hashes and truncating.\n   * @param {string} str - The string to hash\n   * @returns {string} 12-character base36 hash\n   */\n  function simpleHash(str) {\n    // eslint-disable-next-line no-bitwise\n    var h1 = 2166136261 >>> 0; // FNV-1a offset basis\n    // eslint-disable-next-line no-bitwise\n    var h2 = 0x9e3779b1 >>> 0; // Golden ratio constant\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charCodeAt(i);\n      // FNV-1a step on h1\n      // eslint-disable-next-line no-bitwise\n      h1 ^= c;\n      h1 = Math.imul(h1, 16777619);\n\n      // Mix on h2 (inspired by Murmur3 avalanching)\n      h2 = (h2 + c) >>> 0; // eslint-disable-line no-bitwise\n      // eslint-disable-next-line no-bitwise\n      var k = h2 ^ (h2 >>> 16);\n      h2 = Math.imul(k, 2246822507);\n      // eslint-disable-next-line no-bitwise\n      k = h2 ^ (h2 >>> 13);\n      h2 = Math.imul(k, 3266489909);\n      // eslint-disable-next-line no-bitwise\n      h2 = (h2 ^ (h2 >>> 16)) >>> 0;\n    }\n\n    // Combine and encode base36, then truncate to 12 chars\n    // eslint-disable-next-line no-bitwise\n    var s = (h1 >>> 0).toString(36) + (h2 >>> 0).toString(36);\n    if (s.length < 12) {\n      s = (s + 'qwertyuiopasdfghjklz').substring(0, 12);\n    } else if (s.length > 12) {\n      s = s.substring(0, 12);\n    }\n    return s;\n  }\n  /**\n   * Determine whether text should be considered for translation.\n   * @param {string} text - Candidate text\n   * @returns {boolean} True when text looks translatable\n   */\n  function isTranslatableText(text) {\n    if (!text || text.length < 3) {\n      return false;\n    }\n\n    var alphaCount = (text.match(/[a-zA-Z]/g) || []).length;\n    if (alphaCount < text.length * 0.3) {\n      return false;\n    }\n\n    var commonWords = ['ok', 'id', 'url', 'api'];\n    if (commonWords.indexOf(text.toLowerCase()) !== -1) {\n      return false;\n    }\n\n    return true;\n  }\n  Translator.utils.isTranslatableText = isTranslatableText;\n  Translator.utils.simpleHash = simpleHash;\n\n  /**\n   * Determine whether a translation map already contains a key.\n   * @param {Object<string,string>} map - Translation lookup table.\n   * @param {string} key - Structural key to check.\n   * @returns {boolean} True when the key exists in the map.\n   */\n  function hasTranslation(map, key) {\n    return !!(map && Object.prototype.hasOwnProperty.call(map, key));\n  }\n  Translator.utils.hasTranslation = hasTranslation;\n\n  /**\n   * Generate translation key from element structure + direct text (ignoring children)\n   * @param {Element} element - The element to generate key for\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string} 12-character hash key\n   */\n  function generateKey(element, text, type) {\n    if (!element || !text) {\n      return '';\n    }\n\n    var parts = [];\n\n    // Parent context\n    var parent = element.parentElement;\n    if (parent && parent.tagName) {\n      parts.push(parent.tagName.toLowerCase());\n      var parentClasses = collectContextClasses(parent);\n      if (parentClasses) {\n        parts.push(parentClasses);\n      }\n      var parentData = collectDataAttributes(parent);\n      if (parentData) {\n        parts.push(parentData);\n      }\n    }\n\n    // Current element context\n    if (element.tagName) {\n      parts.push(element.tagName.toLowerCase());\n    }\n    var classes = collectContextClasses(element);\n    if (classes) {\n      parts.push(classes);\n    }\n    var dataAttrs = collectDataAttributes(element);\n    if (dataAttrs) {\n      parts.push(dataAttrs);\n    }\n\n    // Type and direct text only (ignore children)\n    if (type && type !== 'text') {\n      parts.push(type);\n    }\n    // Get only direct text nodes (ignore children)\n    var directText = '';\n    for (var i = 0; i < element.childNodes.length; i++) {\n      var node = element.childNodes[i];\n      if (node.nodeType === 3) { // TEXT_NODE\n        directText += node.textContent;\n      }\n    }\n    directText = directText.trim();\n    parts.push(directText);\n\n    return simpleHash(parts.join('.'));\n  }\n  Translator.keys.generateKey = generateKey;\n  Translator.keys.generateKey = generateKey;\n\n  // ============================================================================\n  // KEY ATTRIBUTE MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Set data-xlate-key-{type} attribute\n   * @param {Element} element - The element to set attribute on\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The key value\n   */\n  function setKeyAttribute(element, type, key) {\n    if (!element || !key) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    element.setAttribute(ATTR_KEY_PREFIX + attrType, key);\n  }\n  Translator.attrs.setKeyAttribute = setKeyAttribute;\n  Translator.attrs.setKeyAttribute = setKeyAttribute;\n\n  /**\n   * Get data-xlate-key-{type} attribute\n   * @param {Element} element - The element to get attribute from\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string|null} The key value\n   */\n  function getKeyFromAttributes(element, type) {\n    if (!element) {\n      return null;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    return element.getAttribute(ATTR_KEY_PREFIX + attrType);\n  }\n  Translator.attrs.getKeyFromAttributes = getKeyFromAttributes;\n  Translator.attrs.getKeyFromAttributes = getKeyFromAttributes;\n\n  // ============================================================================\n  // TRANSLATION (Step 3: currentLang !== siteLang)\n  // ============================================================================\n\n  /**\n   * Translate element using bundle\n   * @param {Element} element - The element to translate\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {Object} map - The translation map\n   */\n  function translateElement(element, type, map) {\n    var key = getKeyFromAttributes(element, type);\n    if (!key || !map[key]) {\n      return;\n    }\n\n    if (type === 'text') {\n      element.textContent = map[key];\n    } else {\n      element.setAttribute(type, map[key]);\n    }\n  }\n  /**\n   * Translate a single element using the provided translation map.\n   * @param {Element} element - Element to translate\n   * @param {string} type - Type of translation (text, placeholder, etc)\n   * @param {Object} map - Translation map keyed by generated keys\n   */\n  Translator.capture.translateElement = translateElement;\n  Translator.capture.translateElement = translateElement;\n\n  // ============================================================================\n  // CAPTURE (Step 2: currentLang === siteLang)\n  // ============================================================================\n\n  /**\n   * Detect component from element context\n   * @param {Element} element - The element to detect component for\n   * @returns {string} Component name\n   */\n  function detectComponent(element) {\n    if (!element) {\n      return 'core';\n    }\n\n    var container = element.closest('[data-region]');\n    if (container) {\n      var region = container.getAttribute('data-region');\n      if (region) {\n        return 'region_' + region;\n      }\n    }\n\n    container = element.closest('.block');\n    if (container) {\n      var blockClass = container.className.match(/block_(\\w+)/);\n      if (blockClass) {\n        return 'block_' + blockClass[1];\n      }\n    }\n\n    if (document.body.classList.contains('path-admin')) {\n      return 'admin';\n    }\n\n    return 'core';\n  }\n  /**\n   * Save new key and source text to the backend via Ajax.\n   * @param {Element} element - Source element\n   * @param {string} text - Source text to save\n   * @param {string} type - The attribute/type (text, placeholder, ...)\n   * @param {string} key - Generated structural key\n   * @param {Object} existingMap - Optional map to avoid saving existing keys\n   */\n  Translator.capture.detectComponent = detectComponent;\n  Translator.capture.detectComponent = detectComponent;\n\n  /**\n   * Save translatable string to database\n   * @param {Element} element - The element being saved\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The generated key\n   * @param {Object} existingMap - Optional bundle map to check before saving\n   */\n  function saveToDatabase(element, text, type, key, existingMap) {\n    // If key already exists in the bundle, skip saving\n    if (existingMap && existingMap[key]) {\n      xlateDebug('[XLATE] Skipping save - key exists:', key);\n      return;\n    }\n\n    var component = detectComponent(element);\n    var dedupeKey = component + ':' + key + ':' + type;\n\n    if (detectedStrings.has(dedupeKey)) {\n      return;\n    }\n    detectedStrings.add(dedupeKey);\n\n    xlateDebug('[XLATE] Saving new key:', key, 'component:', component, 'text:', text.substring(0, 50));\n\n    // Determine page-level course id (prefer server-injected XLATE_COURSEID when present)\n    var pageCourseId = 0;\n    if (typeof window !== 'undefined' && typeof window.XLATE_COURSEID !== 'undefined') {\n      pageCourseId = window.XLATE_COURSEID;\n    } else if (typeof M !== 'undefined' && M.cfg && M.cfg.courseid) {\n      pageCourseId = M.cfg.courseid;\n    }\n\n    var curLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var siteLang = (window.__XLATE__ && window.__XLATE__.siteLang) || 'en';\n    var reviewedFlag = (curLang === siteLang) ? 1 : 0;\n\n    Ajax.call([{\n      methodname: 'local_xlate_save_key',\n      args: {\n        component: component,\n        key: key,\n        source: text,\n        lang: curLang,\n        translation: text,\n        // If the current page language equals the site default language, mark\n        // captured source strings as reviewed (human-authored in site language).\n        reviewed: reviewedFlag,\n        courseid: pageCourseId,\n        context: component\n      }\n    }])[0].then(function () {\n      if (window.__XLATE__) {\n        if (!window.__XLATE__.map) {\n          window.__XLATE__.map = {};\n        }\n        window.__XLATE__.map[key] = text;\n      }\n      return true;\n    }).catch(function () {\n      detectedStrings.delete(dedupeKey);\n    });\n  }\n  Translator.capture.saveToDatabase = saveToDatabase;\n  Translator.capture.saveToDatabase = saveToDatabase;\n\n  // ============================================================================\n  // ELEMENT PROCESSING (Step 1: Tag FIRST)\n  // ============================================================================\n\n  /**\n   * Check if element should be ignored\n   * @param {Element} element - The element to check\n   * @returns {boolean} True if should be ignored\n   */\n  function shouldIgnoreElement(element) {\n    if (!element || !element.tagName) {\n      return true;\n    }\n\n    var tagName = element.tagName.toLowerCase();\n    if ([\n      'script', 'style', 'meta', 'link', 'noscript', 'head'\n    ].indexOf(tagName) !== -1) {\n      return true;\n    }\n\n    // Exclude selectors from settings (window.XLATE_EXCLUDE_SELECTORS)\n    if (window.XLATE_EXCLUDE_SELECTORS && Array.isArray(window.XLATE_EXCLUDE_SELECTORS)) {\n      for (var i = 0; i < window.XLATE_EXCLUDE_SELECTORS.length; i++) {\n        var sel = window.XLATE_EXCLUDE_SELECTORS[i];\n        if (!sel) {\n          continue;\n        }\n        try {\n          if (element.matches(sel) || (element.closest && element.closest(sel))) {\n            return true;\n          }\n        } catch (e) {\n          xlateDebug('[XLATE][DEBUG] Invalid selector:', sel, e);\n        }\n      }\n    }\n\n    if (element.hasAttribute('data-xlate-ignore') || element.closest('[data-xlate-ignore]')) {\n      return true;\n    }\n\n    // Do not skip elements just because they already have key attributes;\n    // we rely on processedElements to prevent duplicate work.\n\n    // Admin paths stay blocked to avoid capturing config screens where translators do not run.\n    var currentPath = window.location.pathname || '';\n    var adminPaths = ['/admin/', '/local/xlate/', '/course/modedit.php'];\n    for (var p = 0; p < adminPaths.length; p++) {\n      if (currentPath.indexOf(adminPaths[p]) === 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  Translator.dom.shouldIgnoreElement = shouldIgnoreElement;\n\n\n  /**\n   * Collect any data-xlate-key-* attribute values from an element into a set-like object\n   * @param {Element} el - Element to inspect\n   * @param {Object} keySet - Object used as a set to store keys\n   */\n  function collectKeysFromElement(el, keySet) {\n    var attrs = el && el.attributes;\n    if (!attrs) {\n      return;\n    }\n    for (var j = 0; j < attrs.length; j++) {\n      var a = attrs[j];\n      var name = a && a.name;\n      if (name && name.indexOf(ATTR_KEY_PREFIX) === 0) {\n        var val = a.value;\n        if (val) {\n          keySet[val] = true;\n        }\n      }\n    }\n  }\n  /**\n   * Process a single DOM element: tag, then optionally save or translate.\n   * @param {Element} element - Element to process\n   * @param {Object} map - Translation map\n   * @param {boolean} tagOnly - When true, only add key attributes\n   */\n  function processElement(element, map, tagOnly) {\n    if (shouldIgnoreElement(element) || processedElements.has(element)) {\n      return;\n    }\n    processedElements.add(element);\n\n    var currentLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var siteLang = (window.__XLATE__ && window.__XLATE__.siteLang) || 'en';\n    var isCapture = (currentLang === siteLang);\n\n    // Process text content: only if direct text (excluding children) is non-empty\n    var directText = '';\n    for (var i = 0; i < element.childNodes.length; i++) {\n      var node = element.childNodes[i];\n      if (node.nodeType === 3) { // TEXT_NODE\n        directText += node.textContent;\n      }\n    }\n    directText = directText.trim();\n    if (directText && isTranslatableText(directText)) {\n      var textKey = generateKey(element, directText, 'text');\n      if (textKey) {\n        setKeyAttribute(element, 'text', textKey); // Step 1: TAG\n        if (!tagOnly) {\n          if (isCapture) {\n            saveToDatabase(element, directText, 'text', textKey, map); // Step 2: SAVE (skip if in map)\n          } else if (map) {\n            if (hasTranslation(map, textKey)) {\n              translateElement(element, 'text', map); // Step 3: TRANSLATE\n            } else {\n              queueMissingTranslation(textKey);\n            }\n          }\n        }\n      }\n    }\n\n    // Process attributes\n    ATTRIBUTE_TYPES.forEach(function (attr) {\n      if (!element.hasAttribute(attr)) {\n        return;\n      }\n      var value = element.getAttribute(attr).trim();\n      if (value && isTranslatableText(value)) {\n        var attrKey = generateKey(element, value, attr);\n        if (attrKey) {\n          setKeyAttribute(element, attr, attrKey); // Step 1: TAG\n          if (!tagOnly) {\n            if (isCapture) {\n              saveToDatabase(element, value, attr, attrKey, map); // Step 2: SAVE (skip if in map)\n            } else if (map) {\n              if (hasTranslation(map, attrKey)) {\n                translateElement(element, attr, map); // Step 3: TRANSLATE\n              } else {\n                queueMissingTranslation(attrKey);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  Translator.dom.collectKeysFromElement = collectKeysFromElement;\n\n  /**\n   * Debounced trigger that batches pending keys and requests translations.\n   * @returns {void}\n   */\n  function scheduleMissingFetch() {\n    if (missingFetchTimer !== null) {\n      return;\n    }\n    missingFetchTimer = window.setTimeout(function () {\n      missingFetchTimer = null;\n      if (!pendingTranslationKeys || pendingTranslationKeys.size === 0) {\n        return;\n      }\n      var keys = [];\n      pendingTranslationKeys.forEach(function (k) {\n        keys.push(k);\n      });\n      pendingTranslationKeys.clear();\n      fetchMissingTranslations(keys);\n    }, 200);\n  }\n\n  /**\n   * Request translations for keys discovered after the initial bundle load.\n   * @param {Array<string>} keys - Structural keys requiring translations.\n   * @returns {void}\n   */\n  function fetchMissingTranslations(keys) {\n    if (!keys || !keys.length) {\n      return;\n    }\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n\n    var bundleUrl = window.__XLATE__.bundleUrl || '';\n    if (!bundleUrl) {\n      return;\n    }\n\n    fetch(bundleUrl, {\n      method: 'POST',\n      credentials: 'same-origin',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ keys: keys })\n    })\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (data) {\n        var map = window.__XLATE__.map || {};\n        var translations = (data && data.translations) ? data.translations : data;\n        if (!translations || typeof translations !== 'object') {\n          keys.forEach(function (k) {\n            requestedTranslationKeys.add(k);\n          });\n          return;\n        }\n\n        var updated = false;\n        Object.keys(translations).forEach(function (k) {\n          var value = translations[k];\n          if (!Object.prototype.hasOwnProperty.call(map, k) || map[k] !== value) {\n            map[k] = value;\n            updated = true;\n          }\n        });\n\n        if (updated) {\n          window.__XLATE__.map = map;\n\n          if (window.__XLATE__.cacheKey) {\n            try {\n              var cached = localStorage.getItem(window.__XLATE__.cacheKey);\n              if (cached) {\n                var cachedMap = JSON.parse(cached);\n                if (cachedMap && typeof cachedMap === 'object') {\n                  Object.keys(translations).forEach(function (k) {\n                    cachedMap[k] = translations[k];\n                  });\n                  localStorage.setItem(window.__XLATE__.cacheKey, JSON.stringify(cachedMap));\n                }\n              }\n            } catch (e) {\n              // Ignore cache sync errors.\n            }\n          }\n\n          processedElements = new WeakSet();\n          walk(document.body, map, false);\n        }\n\n        keys.forEach(function (k) {\n          requestedTranslationKeys.add(k);\n        });\n      })\n      .catch(function (err) {\n        keys.forEach(function (k) {\n          requestedTranslationKeys.delete(k);\n        });\n        xlateDebug('[XLATE] Missing translation fetch failed', err);\n      });\n  }\n\n  /**\n   * Queue a translation key for deferred fetching if it is not already pending.\n   * @param {string} key - Structural key needing translation.\n   * @returns {void}\n   */\n  function queueMissingTranslation(key) {\n    if (!key || pendingTranslationKeys.has(key) || requestedTranslationKeys.has(key)) {\n      return;\n    }\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n    pendingTranslationKeys.add(key);\n    scheduleMissingFetch();\n  }\n  Translator.dom.processElement = processElement;\n\n  // ============================================================================\n  // DOM WALKING\n  // ============================================================================\n\n  /**\n   * Walk DOM and process elements\n   * @param {Element} root - Root element to start from\n   * @param {Object} map - The translation map\n   * @param {boolean} tagOnly - When true, only tag keys without saving/translating\n   */\n  function walk(root, map, tagOnly) {\n    if (!root) {\n      return;\n    }\n\n    // If capture selectors are set, only walk those areas\n    var captureSelectors = (window.XLATE_CAPTURE_SELECTORS &&\n      Array.isArray(window.XLATE_CAPTURE_SELECTORS) &&\n      window.XLATE_CAPTURE_SELECTORS.length)\n      ? window.XLATE_CAPTURE_SELECTORS : null;\n\n    var roots = [];\n    if (captureSelectors) {\n      captureSelectors.forEach(function (sel) {\n        try {\n          var found = document.querySelectorAll(sel);\n          for (var i = 0; i < found.length; i++) {\n            roots.push(found[i]);\n          }\n        } catch (e) { /* Ignore invalid selectors */ }\n      });\n      if (!roots.length) {\n        roots = [root]; // Fallback to body\n      }\n    } else {\n      roots = [root];\n    }\n\n    roots.forEach(function (scanRoot) {\n      var stack = [scanRoot];\n      while (stack.length) {\n        var el = stack.pop();\n        if (el.nodeType === 1) {\n          // If this element should be ignored (exclusion zone), skip its subtree\n          if (shouldIgnoreElement(el)) {\n            continue;\n          }\n          processElement(el, map, tagOnly);\n          var children = el.children || [];\n          for (var i = 0; i < children.length; i++) {\n            stack.push(children[i]);\n          }\n        }\n      }\n    });\n  }\n  Translator.dom.walk = walk;\n  Translator.dom.walk = walk;\n\n  /**\n   * Run translator\n   * @param {Object<string,string>} map Translation map keyed by structural hash.\n   * @returns {void}\n   */\n  function run(map) {\n    try {\n      walk(document.body, map || {});\n\n      // Fallback: periodic refreshes to catch late-injected content\n      setTimeout(function () {\n        walk(document.body, map || {});\n      }, 1000);\n      setTimeout(function () {\n        walk(document.body, map || {});\n      }, 3000);\n      setTimeout(function () {\n        walk(document.body, map || {});\n      }, 6000);\n\n      var mo = new MutationObserver(function (muts) {\n        muts.forEach(function (mutation) {\n          Array.prototype.slice.call(mutation.addedNodes || []).forEach(function (node) {\n            if (node.nodeType === 1) {\n              walk(node, map || {});\n            }\n          });\n        });\n      });\n      mo.observe(document.body, { childList: true, subtree: true });\n\n      if (typeof window.addEventListener === 'function') {\n        ['focus', 'click', 'scroll'].forEach(function (eventType) {\n          document.addEventListener(eventType, function () {\n            var now = Date.now();\n            if (now - lastProcessTime > processThrottle) {\n              lastProcessTime = now;\n              setTimeout(function () {\n                walk(document.body, map || {});\n              }, 100);\n            }\n          }, true);\n        });\n      }\n    } finally {\n      document.documentElement.classList.remove('xlate-loading');\n    }\n  }\n  Translator.api.run = run;\n\n  /**\n   * Get source value for an element based on the key attribute type.\n   * @param {Element} el - Element to inspect\n   * @param {string} typename - Attribute type (content for text)\n   * @returns {string} Source value or empty string\n   */\n  function getSourceForElementAttr(el, typename) {\n    if (!el) {\n      return '';\n    }\n    if (typename === 'content') {\n      var dt = '';\n      for (var dn = 0; dn < el.childNodes.length; dn++) {\n        var node = el.childNodes[dn];\n        if (node.nodeType === 3) {\n          dt += node.textContent;\n        }\n      }\n      return dt.trim();\n    }\n    try {\n      return el.getAttribute(typename) || '';\n    } catch (e) {\n      return '';\n    }\n  }\n\n  /**\n   * Collect key set and first-seen details (component + source) for keys under root.\n   * @param {Element} root - Root to scan\n   * @returns {Object} {keySet: {}, keyDetails: {}}\n   */\n  function collectKeySetAndDetails(root) {\n    var keySet = {};\n    var keyDetails = {};\n    var all = (root && root.querySelectorAll) ? root.querySelectorAll('*') : [];\n    for (var i = 0; i < all.length; i++) {\n      var el = all[i];\n      collectKeysFromElement(el, keySet);\n      var attrs = el && el.attributes;\n      if (!attrs) {\n        continue;\n      }\n      for (var j = 0; j < attrs.length; j++) {\n        var attrname = attrs[j] && attrs[j].name;\n        if (!attrname || attrname.indexOf(ATTR_KEY_PREFIX) !== 0) {\n          continue;\n        }\n        var aval = attrs[j].value;\n        if (!aval) {\n          continue;\n        }\n        if (keyDetails[aval]) {\n          continue;\n        }\n        var typename = attrname.substring(ATTR_KEY_PREFIX.length);\n        var src = getSourceForElementAttr(el, typename);\n        keyDetails[aval] = {\n          component: detectComponent(el),\n          source: src\n        };\n      }\n    }\n    return { keySet: keySet, keyDetails: keyDetails };\n  }\n\n  /**\n   * @typedef {Object} TranslatorConfig\n   * @property {string} lang Current page language code.\n   * @property {string} siteLang Site default language used for capture mode.\n   * @property {string} bundleurl REST endpoint returning translation bundles.\n   * @property {string} version Bundle version hash used for cache busting.\n   * @property {boolean} isEditing True when Moodle editing mode is active.\n   */\n\n  /**\n   * Initialize translator\n   * @param {TranslatorConfig} config Configuration object injected server-side.\n   */\n  function init(config) {\n    document.documentElement.classList.add('xlate-loading');\n\n    // If editing mode is enabled, skip all capture/tagging logic\n    if (config.isEditing) {\n      xlateDebug('[XLATE] Edit mode detected (isEditing=true): skipping translation/capture logic.');\n      document.documentElement.classList.remove('xlate-loading');\n      return;\n    }\n\n    // No autodetect config: auto-detection is always enabled.\n\n    window.__XLATE__ = {\n      lang: config.lang,\n      siteLang: config.siteLang,\n      map: {},\n      sourceMap: {},\n      bundleUrl: config.bundleurl || '',\n      version: config.version || '',\n      cacheKey: ''\n    };\n\n    /**\n     * Process bundle data\n     * @param {Object} bundleData - The bundle data\n     */\n    var currentLang = config.lang;\n    var siteLang = config.siteLang;\n    var isCapture = (currentLang === siteLang);\n    window.__XLATE__.isCapture = isCapture;\n\n    // Detect course id exposed by server-side hook or fallback to M.cfg\n    var courseId = null;\n    if (typeof window !== 'undefined' && typeof window.XLATE_COURSEID !== 'undefined') {\n      courseId = window.XLATE_COURSEID;\n    } else if (typeof M !== 'undefined' && M.cfg && M.cfg.courseid) {\n      courseId = M.cfg.courseid;\n    }\n\n    xlateDebug('[XLATE] Initializing:', {\n      currentLang: currentLang,\n      siteLang: siteLang,\n      isCapture: isCapture,\n      courseId: courseId\n    });\n    // Auto-detect enabled by default (autoDetectEnabled removed)\n\n    // In capture mode: fetch bundle first to check existing keys, then tag + save only new ones\n    if (isCapture) {\n      xlateDebug('[XLATE] Capture mode - starting tag-only pass');\n      processedElements = new WeakSet();\n      // Tag-only first pass to generate keys\n      walk(document.body, {}, true);\n\n      // Collect all tagged keys and record a first-seen component+source for each key\n      var collected = collectKeySetAndDetails(document);\n      var keySetCap = collected.keySet;\n      var keyDetails = collected.keyDetails;\n      var keysCap = Object.keys(keySetCap);\n\n      xlateDebug('[XLATE] Collected', keysCap.length, 'keys from DOM');\n\n      if (keysCap.length === 0) {\n        xlateDebug('[XLATE] No keys found, skipping bundle fetch');\n        run({});\n        return;\n      }\n\n      xlateDebug('[XLATE] Fetching bundle to check existing keys...');\n      // Fetch existing translations for these keys\n      fetch(config.bundleurl, {\n        method: 'POST',\n        credentials: 'same-origin',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ keys: keysCap })\n      })\n        .then(function (response) {\n          return response.json();\n        })\n        .then(function (map) {\n          var translations = (map && map.translations) ? map.translations : map;\n          var sourceMap = (map && map.sourceMap) ? map.sourceMap : {};\n          var associations = (map && map.associations) ? map.associations : {};\n          if (!translations || typeof translations !== 'object') {\n            translations = {};\n          }\n          window.__XLATE__.map = translations;\n          window.__XLATE__.sourceMap = sourceMap;\n\n          var existingCount = Object.keys(translations).length;\n          xlateDebug('[XLATE] Bundle returned', existingCount, 'existing translations');\n\n          // If the server returned per-key association information and we have a page-level\n          // course id, bulk-associate any keys that are not yet associated for this course.\n          // The server may only return associations to authorized users.\n          if (courseId && associations && typeof associations === 'object') {\n            var toAssociate = [];\n            for (var ti = 0; ti < keysCap.length; ti++) {\n              var k = keysCap[ti];\n              if (!associations[k]) {\n                var detail = keyDetails[k] || null;\n                if (detail) {\n                  toAssociate.push({\n                    component: detail.component,\n                    key: k,\n                    source: detail.source || ''\n                  });\n                }\n              }\n            }\n            if (toAssociate.length) {\n              xlateDebug('[XLATE] Associating', toAssociate.length, 'keys with course', courseId);\n              try {\n                // Fire-and-forget: we don't need to block the UI on association results.\n                Ajax.call([{\n                  methodname: 'local_xlate_associate_keys',\n                  args: {\n                    keys: toAssociate,\n                    courseid: courseId,\n                    context: ''\n                  }\n                }]);\n              } catch (e) {\n                xlateDebug('[XLATE] Bulk-associate exception', e);\n              }\n            }\n          }\n\n          // Now walk again to save only keys NOT in the bundle\n          processedElements = new WeakSet();\n          walk(document.body, translations, false);\n          run(translations);\n          return true;\n        })\n        .catch(function (err) {\n          xlateDebug('[XLATE] Bundle fetch failed:', err);\n          // If bundle fetch fails, save everything\n          processedElements = new WeakSet();\n          walk(document.body, {}, false);\n          run({});\n        });\n      return;\n    }\n\n    xlateDebug('[XLATE] Translation mode - starting tag-only pass');\n    // Translation mode: pre-tag, collect keys, request filtered bundle, then translate\n    try {\n      // Pre-tag only\n      processedElements = new WeakSet();\n      walk(document.body, {}, true);\n\n      // Collect tagged keys from DOM\n      var keySet = {};\n      var all = document.querySelectorAll('*');\n      for (var i = 0; i < all.length; i++) {\n        collectKeysFromElement(all[i], keySet);\n      }\n      var keys = Object.keys(keySet);\n\n      // Short-circuit if no keys\n      if (keys.length === 0) {\n        run({});\n        return;\n      }\n\n      var k = 'xlate:' + config.lang + ':' + config.version + ':keys:' + keys.length;\n      window.__XLATE__.cacheKey = k;\n      var cached = null;\n      try {\n        cached = localStorage.getItem(k);\n      } catch (e) {\n        // Ignore\n      }\n      if (cached) {\n        try {\n          var cachedMap = JSON.parse(cached);\n          if (cachedMap && typeof cachedMap === 'object') {\n            window.__XLATE__.map = cachedMap;\n            processedElements = new WeakSet();\n            run(cachedMap);\n          }\n        } catch (e) {\n          // Ignore\n        }\n      }\n\n      fetch(config.bundleurl, {\n        method: 'POST',\n        credentials: 'same-origin',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ keys: keys })\n      })\n        .then(function (response) {\n          return response.json();\n        })\n        .then(function (map) {\n          // Accept either flat map or legacy wrapper\n          var translations = (map && map.translations) ? map.translations : map;\n          if (!translations || typeof translations !== 'object') {\n            translations = {};\n          }\n          try {\n            localStorage.setItem(k, JSON.stringify(translations));\n          } catch (e) {\n            // Ignore\n          }\n          window.__XLATE__.map = translations;\n          processedElements = new WeakSet();\n          run(translations);\n          return true;\n        })\n        .catch(function () {\n          run({});\n        });\n    } catch (err) {\n      run({});\n    }\n  }\n  Translator.api.init = init;\n\n  /**\n   * Enable or disable auto-detect\n   * @param {boolean} enabled - Whether to enable auto-detect\n   */\n\n\n  Translator.run = run;\n  Translator.init = init;\n\n  return Translator;\n});"],"names":["define","Ajax","ATTRIBUTE_TYPES","detectedStrings","Set","processedElements","WeakSet","lastProcessTime","pendingTranslationKeys","requestedTranslationKeys","missingFetchTimer","Translator","xlateDebug","window","XLATE_DEBUG","console","debug","apply","arguments","log","collectContextClasses","element","classList","blacklist","classes","Array","prototype","forEach","call","cls","length","indexOf","test","push","join","collectDataAttributes","attributes","dataAttrs","i","attr","name","value","simpleHash","str","h1","h2","c","charCodeAt","Math","imul","k","s","toString","substring","isTranslatableText","text","match","toLowerCase","hasTranslation","map","key","Object","hasOwnProperty","generateKey","type","parts","parent","parentElement","tagName","parentClasses","parentData","directText","childNodes","node","nodeType","textContent","trim","setKeyAttribute","attrType","setAttribute","getKeyFromAttributes","getAttribute","translateElement","detectComponent","container","closest","region","blockClass","className","document","body","contains","saveToDatabase","existingMap","component","dedupeKey","has","add","pageCourseId","XLATE_COURSEID","M","cfg","courseid","curLang","__XLATE__","lang","language","reviewedFlag","siteLang","methodname","args","source","translation","reviewed","context","then","catch","delete","shouldIgnoreElement","XLATE_EXCLUDE_SELECTORS","isArray","sel","matches","e","hasAttribute","currentPath","location","pathname","adminPaths","p","collectKeysFromElement","el","keySet","attrs","j","a","val","processElement","tagOnly","isCapture","textKey","queueMissingTranslation","attrKey","scheduleMissingFetch","setTimeout","size","keys","clear","bundleUrl","fetch","method","credentials","headers","JSON","stringify","response","json","data","translations","updated","cacheKey","cached","localStorage","getItem","cachedMap","parse","setItem","walk","err","fetchMissingTranslations","root","captureSelectors","XLATE_CAPTURE_SELECTORS","roots","found","querySelectorAll","scanRoot","stack","pop","children","run","MutationObserver","muts","mutation","slice","addedNodes","observe","childList","subtree","addEventListener","eventType","now","Date","documentElement","remove","getSourceForElementAttr","typename","dt","dn","init","config","isEditing","sourceMap","bundleurl","version","currentLang","courseId","collected","keyDetails","all","attrname","aval","src","collectKeySetAndDetails","keySetCap","keysCap","associations","toAssociate","ti","detail","utils","capture","dom","api"],"mappings":"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"}