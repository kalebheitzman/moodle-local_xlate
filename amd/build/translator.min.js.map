{"version":3,"file":"translator.min.js","sources":["../src/translator.js"],"sourcesContent":["// Local/xlate/amd/src/translator.js\ndefine(['core/ajax'], function (Ajax) {\n  var autoDetectEnabled = true;\n  var detectedStrings = new Set();\n  var processedElements = new WeakSet();\n\n  /**\n   * Translate a single element when metadata is present.\n   * @param {Element} node DOM node to translate.\n   * @param {Object<string, string>} map Translation map.\n   * @returns {void}\n   */\n  function translateNode(node, map) {\n    if (node.nodeType !== 1) {\n      return;\n    }\n    var key = node.getAttribute && node.getAttribute('data-xlate');\n    if (key && map[key]) {\n      node.textContent = map[key];\n    }\n    ['placeholder', 'title', 'alt', 'aria-label'].forEach(function (attr) {\n      var akey = node.getAttribute && node.getAttribute('data-xlate-' + attr);\n      if (akey && map[akey]) {\n        node.setAttribute(attr, map[akey]);\n      }\n    });\n  }\n\n  /**\n   * Check if element should be ignored for auto-detection\n   * @param {Element} element - Element to check\n   * @returns {boolean} True if should be ignored\n   */\n  function shouldIgnoreElement(element) {\n    var tagName = element.tagName.toLowerCase();\n\n    // Skip script, style, meta tags\n    if (['script', 'style', 'meta', 'link', 'noscript', 'head'].includes(tagName)) {\n      return true;\n    }\n\n    // Skip if marked to ignore\n    if (element.hasAttribute('data-xlate-ignore') ||\n      element.closest('[data-xlate-ignore]')) {\n      return true;\n    }\n\n    // Skip if already has xlate attributes\n    if (element.hasAttribute('data-xlate') ||\n      element.hasAttribute('data-xlate-placeholder') ||\n      element.hasAttribute('data-xlate-title') ||\n      element.hasAttribute('data-xlate-alt')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Generate component name from element context\n   * @param {Element} element - Element to analyze\n   * @returns {string} Component name\n   */\n  function detectComponent(element) {\n    // Check for Moodle-specific containers\n    var container = element.closest('[data-region]');\n    if (container) {\n      var region = container.getAttribute('data-region');\n      if (region) {\n        return 'region_' + region;\n      }\n    }\n\n    // Check for block containers\n    container = element.closest('.block');\n    if (container) {\n      var blockClass = container.className.match(/block_(\\w+)/);\n      if (blockClass) {\n        return 'block_' + blockClass[1];\n      }\n    }\n\n    // Check for course module containers\n    container = element.closest('.activity');\n    if (container) {\n      var activityClass = container.className.match(/modtype_(\\w+)/);\n      if (activityClass) {\n        return 'mod_' + activityClass[1];\n      }\n    }\n\n    // Check for admin pages\n    if (document.body.classList.contains('path-admin')) {\n      return 'admin';\n    }\n\n    // Default to core\n    return 'core';\n  }\n\n  /**\n   * Generate translation key from element content and context\n   * @param {Element} element - Element to generate key for\n   * @param {string} text - Text content\n   * @param {string} type - Type of content (text, placeholder, title, alt)\n   * @returns {string} Generated key\n   */\n  function generateKey(element, text, type) {\n    var tagName = element.tagName.toLowerCase();\n    var keyParts = [];\n\n    // Add context based on element type\n    if (type === 'placeholder') {\n      keyParts.push('Input');\n    } else if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) {\n      keyParts.push('Heading');\n    } else if (tagName === 'button' || (tagName === 'input' && element.type === 'submit')) {\n      keyParts.push('Button');\n    } else if (tagName === 'a') {\n      keyParts.push('Link');\n    } else if (tagName === 'label') {\n      keyParts.push('Label');\n    } else if (type === 'alt') {\n      keyParts.push('Image');\n    } else if (type === 'title') {\n      keyParts.push('Title');\n    }\n\n    // Clean and format text as key part\n    var cleanText = text\n      .replace(/[^\\w\\s]/g, '') // Remove special chars\n      .replace(/\\s+/g, ' ') // Normalize spaces\n      .trim()\n      .split(' ')\n      .map(function (word) {\n        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n      })\n      .join('');\n\n    if (cleanText) {\n      keyParts.push(cleanText);\n    } else {\n      keyParts.push('Text');\n    }\n\n    // Add type suffix if not text content\n    if (type && type !== 'text') {\n      keyParts.push(type.charAt(0).toUpperCase() + type.slice(1));\n    }\n\n    return keyParts.join('.');\n  }\n\n  /**\n   * Auto-detect and save translatable string\n   * @param {Element} element - Element containing the string\n   * @param {string} text - Text content to save\n   * @param {string} type - Type of content (text, placeholder, title, alt)\n   */\n  function autoDetectString(element, text, type) {\n    if (!autoDetectEnabled || !text || text.length < 2) {\n      return;\n    }\n\n    // Skip if already processed\n    var uniqueId = text + ':' + type + ':' + element.tagName;\n    if (detectedStrings.has(uniqueId)) {\n      return;\n    }\n\n    detectedStrings.add(uniqueId);\n\n    var component = detectComponent(element);\n    var key = generateKey(element, text, type);\n\n    // Save via AJAX\n    Ajax.call([{\n      methodname: 'local_xlate_save_key',\n      args: {\n        component: component,\n        key: key,\n        source: text,\n        lang: M.cfg.language || 'en',\n        translation: text\n      }\n    }])[0].then(function() {\n      // Apply the attribute to the element\n      var attrName = 'data-xlate' + (type !== 'text' ? '-' + type : '');\n      element.setAttribute(attrName, key);\n\n      // Update the global map\n      if (window.__XLATE__ && window.__XLATE__.map) {\n        window.__XLATE__.map[key] = text;\n      }\n\n      return true;\n    }).catch(function() {\n      // Silently fail - don't break the page if auto-detection fails\n      detectedStrings.delete(uniqueId);\n    });\n  }\n\n  /**\n   * Auto-detect translatable content in an element\n   * @param {Element} element - Element to analyze\n   */\n  function autoDetectElement(element) {\n    if (shouldIgnoreElement(element) || processedElements.has(element)) {\n      return;\n    }\n\n    processedElements.add(element);\n\n    // Check text content\n    if (element.childNodes.length === 1 &&\n      element.childNodes[0].nodeType === 3 && // Text node\n      element.textContent.trim()) {\n      autoDetectString(element, element.textContent.trim(), 'text');\n    }\n\n    // Check attributes\n    if (element.hasAttribute('placeholder') && element.getAttribute('placeholder').trim()) {\n      autoDetectString(element, element.getAttribute('placeholder').trim(), 'placeholder');\n    }\n\n    if (element.hasAttribute('title') && element.getAttribute('title').trim()) {\n      autoDetectString(element, element.getAttribute('title').trim(), 'title');\n    }\n\n    if (element.hasAttribute('alt') && element.getAttribute('alt').trim()) {\n      autoDetectString(element, element.getAttribute('alt').trim(), 'alt');\n    }\n  }\n\n  /**\n   * Walk the DOM depth-first and translate every eligible child.\n   * @param {Element} root Root element to process.\n   * @param {Object<string, string>} map Translation map.\n   * @returns {void}\n   */\n  function walk(root, map) {\n    var stack = [root];\n    while (stack.length) {\n      var el = stack.pop();\n      if (el.nodeType === 1) {\n        if (el.hasAttribute && el.hasAttribute('data-xlate-ignore')) {\n          continue;\n        }\n\n        // Translate existing keys\n        translateNode(el, map);\n\n        // Auto-detect new strings if enabled\n        if (autoDetectEnabled) {\n          autoDetectElement(el);\n        }\n\n        var children = el.children || [];\n        for (var i = 0; i < children.length; i++) {\n          stack.push(children[i]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Entry point: translates current DOM and observes future updates.\n   * @param {Object<string, string>} map Translation map.\n   * @returns {void}\n   */\n  function run(map) {\n    try {\n      walk(document.body, map || {});\n\n      // Start auto-detection after initial translation\n      if (autoDetectEnabled) {\n        setTimeout(function () {\n          walk(document.body, map || {});\n        }, 1000); // Delay to let page fully load\n      }\n\n      var mo = new MutationObserver(function (muts) {\n        muts.forEach(function (m) {\n          (m.addedNodes || []).forEach(function (n) {\n            if (n.nodeType === 1) {\n              walk(n, map || {});\n            }\n          });\n        });\n      });\n      mo.observe(document.body, { childList: true, subtree: true });\n    } finally {\n      document.documentElement.classList.remove('xlate-loading');\n    }\n  }\n\n  /**\n   * Initialize the translator with config from Moodle.\n   * @param {Object} config Configuration object with lang, version, bundleurl.\n   * @returns {void}\n   */\n  function init(config) {\n    document.documentElement.classList.add('xlate-loading');\n    var k = 'xlate:' + config.lang + ':' + config.version;\n\n    window.__XLATE__ = { lang: config.lang, map: {} };\n\n    try {\n      var cached = localStorage.getItem(k);\n      if (cached) {\n        var bundle = JSON.parse(cached);\n        window.__XLATE__.map = bundle;\n        run(bundle);\n      }\n\n      fetch(config.bundleurl, { credentials: 'same-origin' })\n        .then(function (r) {\n          return r.json();\n        })\n        .then(function (bundle) {\n          try {\n            localStorage.setItem(k, JSON.stringify(bundle));\n          } catch (e) {\n            // Storage quota exceeded, ignore\n          }\n          if (!cached) {\n            window.__XLATE__.map = bundle;\n            run(bundle);\n          }\n\n          return true;\n        })\n        .catch(function () {\n          if (!cached) {\n            run({});\n          }\n        });\n    } catch (e) {\n      fetch(config.bundleurl)\n        .then(function (r) {\n          return r.json();\n        })\n        .then(function (bundle) {\n          window.__XLATE__.map = bundle;\n          run(bundle);\n\n          return true;\n        })\n        .catch(function () {\n          run({});\n        });\n    }\n  }\n\n  /**\n   * Enable or disable automatic string detection\n   * @param {boolean} enabled - Whether to enable auto-detection\n   */\n  function setAutoDetect(enabled) {\n    autoDetectEnabled = enabled;\n  }\n\n  return {\n    run: run,\n    init: init,\n    setAutoDetect: setAutoDetect\n  };\n});"],"names":["define","Ajax","autoDetectEnabled","detectedStrings","Set","processedElements","WeakSet","translateNode","node","map","nodeType","key","getAttribute","textContent","forEach","attr","akey","setAttribute","autoDetectString","element","text","type","length","uniqueId","tagName","has","add","component","container","closest","region","blockClass","className","match","activityClass","document","body","classList","contains","detectComponent","toLowerCase","keyParts","push","includes","cleanText","replace","trim","split","word","charAt","toUpperCase","slice","join","generateKey","call","methodname","args","source","lang","M","cfg","language","translation","then","attrName","window","__XLATE__","catch","delete","walk","root","stack","el","pop","hasAttribute","shouldIgnoreElement","childNodes","children","i","run","setTimeout","MutationObserver","muts","m","addedNodes","n","observe","childList","subtree","documentElement","remove","init","config","k","version","cached","localStorage","getItem","bundle","JSON","parse","fetch","bundleurl","credentials","r","json","setItem","stringify","e","setAutoDetect","enabled"],"mappings":"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"}