{"version":3,"file":"translator.min.js","sources":["../src/translator.js"],"sourcesContent":["// Local/xlate/amd/src/translator.js\n// Handles DOM translation, automatic key capture, and fuzzy key attribution.\ndefine(['core/ajax'], function (Ajax) {\n  var ATTR_KEY_PREFIX = 'data-xlate-key-';\n  var LEGACY_ATTR_PREFIX = 'data-xlate-';\n  var ATTRIBUTE_TYPES = ['placeholder', 'title', 'alt', 'aria-label'];\n\n  var autoDetectEnabled = true;\n  var detectedStrings = new Set();\n  var processedElements = new WeakSet();\n  var lastProcessTime = 0;\n  var processThrottle = 250; // Minimum ms between full DOM scans\n\n  /**\n   * Convert a string to PascalCase.\n   * @param {string} value\n   * @returns {string}\n   */\n  function toPascalCase(value) {\n    if (!value) {\n      return '';\n    }\n    return value\n      .split(/[\\s_\\-]+/)\n      .filter(function (part) {\n        return part.length > 0;\n      })\n      .map(function (part) {\n        return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n      })\n      .join('');\n  }\n\n  /**\n   * Normalise text for fuzzy key matching.\n   * @param {string} text\n   * @returns {string}\n   */\n  function normalizeTextForKey(text) {\n    if (!text) {\n      return '';\n    }\n\n    var normalised = text;\n    try {\n      if (normalised.normalize) {\n        normalised = normalised.normalize('NFKC');\n      }\n    } catch (err) {\n      // Ignore normalization errors (older browsers)\n    }\n\n    normalised = normalised.toLowerCase()\n      .replace(/[\\u200B-\\u200D\\uFEFF]/g, ''); // Remove zero-width chars\n\n    try {\n      normalised = normalised.replace(/[^\\p{L}\\p{N}]+/gu, ' ');\n    } catch (err) {\n      normalised = normalised.replace(/[^0-9a-zA-Z]+/g, ' ');\n    }\n\n    normalised = normalised.replace(/\\s+/g, ' ').trim();\n    return normalised;\n  }\n\n  /**\n   * Compute a stable hash from normalised text (first 8 chars of base64).\n   * @param {string} normalised\n   * @returns {string}\n   */\n  function computeHash(normalised) {\n    if (!normalised) {\n      return '';\n    }\n\n    var base;\n    try {\n      base = btoa(unescape(encodeURIComponent(normalised)));\n    } catch (err) {\n      // Fallback: derive from char codes when btoa can't handle input\n      var charcodes = [];\n      for (var i = 0; i < normalised.length; i++) {\n        charcodes.push(normalised.charCodeAt(i).toString(16));\n      }\n      base = charcodes.join('');\n    }\n\n    base = base.replace(/[^A-Za-z0-9]/g, '');\n    if (base.length < 8) {\n      base = (base + 'XXXXXXXX').substring(0, 8);\n    } else {\n      base = base.substring(0, 8);\n    }\n\n    return base.toUpperCase();\n  }\n\n\n  /**\n   * Build a fingerprint from text (slug + hash) and expose normalised form.\n   * @param {string} text\n   * @returns {{slug: string, hash: string, normalized: string}}\n   */\n  function createTextFingerprint(text) {\n    var normalised = normalizeTextForKey(text);\n    if (!normalised) {\n      return { slug: '', hash: '', normalized: '' };\n    }\n\n    var words = normalised.split(' ');\n    var slugParts = [];\n    for (var i = 0; i < words.length && slugParts.length < 4; i++) {\n      if (words[i].length === 0) {\n        continue;\n      }\n      slugParts.push(toPascalCase(words[i]));\n    }\n    var slug = slugParts.join('');\n    if (!slug) {\n      slug = 'Text';\n    }\n    if (slug.length > 48) {\n      slug = slug.substring(0, 48);\n    }\n\n    return {\n      slug: slug,\n      hash: computeHash(normalised),\n      normalized: normalised\n    };\n  }\n\n  /**\n   * Set the appropriate key attribute on an element.\n   * @param {Element} element\n   * @param {string} type\n   * @param {string} key\n   */\n  function setKeyAttribute(element, type, key) {\n    if (!element || !key) {\n      return;\n    }\n\n    // Always use data-xlate-key-{type} format for consistency\n    var attrType = type === 'text' ? 'content' : type;\n    element.setAttribute(ATTR_KEY_PREFIX + attrType, key);\n  }\n\n  /**\n   * Retrieve an existing key attribute from the element.\n   * @param {Element} element\n   * @param {string} type\n   * @returns {string|null}\n   */\n  function getKeyFromAttributes(element, type) {\n    if (!element) {\n      return null;\n    }\n\n    var attrType = type === 'text' ? 'content' : type;\n    return element.getAttribute(ATTR_KEY_PREFIX + attrType) || element.getAttribute(LEGACY_ATTR_PREFIX + attrType);\n  }\n\n  /**\n   * Translate a single element when metadata is present.\n   * @param {Element} node DOM node to translate.\n   * @param {Object<string, string>} map Translation map.\n   * @returns {void}\n   */\n  function translateNode(node, map) {\n    if (!node || node.nodeType !== 1) {\n      return;\n    }\n\n    var key = getKeyFromAttributes(node, 'text');\n    if (key && map[key]) {\n      node.textContent = map[key];\n      setKeyAttribute(node, 'text', key); // Ensure key is visible in DOM\n    } else if (node.childNodes.length === 1 && node.childNodes[0].nodeType === 3) {\n      var textContent = node.textContent.trim();\n      var normalized = normalizeTextForKey(textContent);\n      if (normalized && window.__XLATE__ && window.__XLATE__.sourceMap) {\n        var translationKey = window.__XLATE__.sourceMap[normalized];\n        if (translationKey && map[translationKey]) {\n          setKeyAttribute(node, 'text', translationKey); // Inject key before translation\n          node.textContent = map[translationKey];\n        }\n      }\n    }\n\n    ATTRIBUTE_TYPES.forEach(function (attr) {\n      var attrKey = getKeyFromAttributes(node, attr);\n      if (attrKey && map[attrKey]) {\n        node.setAttribute(attr, map[attrKey]);\n        setKeyAttribute(node, attr, attrKey); // Ensure key is visible in DOM\n        return;\n      }\n\n      var value = node.getAttribute && node.getAttribute(attr);\n      if (!value) {\n        return;\n      }\n\n      var normalisedAttr = normalizeTextForKey(value);\n      if (normalisedAttr && window.__XLATE__ && window.__XLATE__.sourceMap) {\n        var attrTranslationKey = window.__XLATE__.sourceMap[normalisedAttr];\n        if (attrTranslationKey && map[attrTranslationKey]) {\n          node.setAttribute(attr, map[attrTranslationKey]);\n          setKeyAttribute(node, attr, attrTranslationKey); // Inject key before translation\n        }\n      }\n    });\n  }\n\n  /**\n   * Check if element should be ignored for auto-detection\n   * @param {Element} element - Element to check\n   * @returns {boolean} True if should be ignored\n   */\n  function shouldIgnoreElement(element) {\n    if (!element || !element.tagName) {\n      return true;\n    }\n\n    var tagName = element.tagName.toLowerCase();\n\n    if (['script', 'style', 'meta', 'link', 'noscript', 'head'].indexOf(tagName) !== -1) {\n      return true;\n    }\n\n    if (element.hasAttribute('data-xlate-ignore') || element.closest('[data-xlate-ignore]')) {\n      return true;\n    }\n\n    // Check for content key (text content)\n    if (element.hasAttribute(ATTR_KEY_PREFIX + 'content') ||\n      element.hasAttribute(LEGACY_ATTR_PREFIX + 'content')) {\n      return true;\n    }\n\n    // Check for attribute keys\n    for (var i = 0; i < ATTRIBUTE_TYPES.length; i++) {\n      if (element.hasAttribute(ATTR_KEY_PREFIX + ATTRIBUTE_TYPES[i]) ||\n        element.hasAttribute(LEGACY_ATTR_PREFIX + ATTRIBUTE_TYPES[i])) {\n        return true;\n      }\n    }\n\n    var currentPath = window.location.pathname || '';\n    var adminPaths = [\n      '/admin/',\n      '/local/xlate/',\n      '/course/modedit.php',\n      '/grade/edit/',\n      '/backup/',\n      '/restore/',\n      '/user/editadvanced.php'\n    ];\n\n    for (var p = 0; p < adminPaths.length; p++) {\n      if (currentPath.indexOf(adminPaths[p]) === 0) {\n        return true;\n      }\n    }\n\n    var adminSelectors = [\n      '.navbar', '.navigation', '.breadcrumb', '.nav',\n      '.admin-menu', '.settings-menu', '.user-menu',\n      '.page-header-headings', '.page-context-header',\n      '.activity-navigation', '.course-content-header',\n      '.block_settings', '.block_navigation',\n      '#page-navbar', '#nav-drawer', '.drawer',\n      '.form-autocomplete-suggestions', '.popover',\n      '.tooltip', '.dropdown-menu'\n    ];\n\n    for (var iSel = 0; iSel < adminSelectors.length; iSel++) {\n      if (element.closest(adminSelectors[iSel])) {\n        return true;\n      }\n    }\n\n    var adminClasses = [\n      'editing', 'editor', 'admin-only', 'teacher-only',\n      'form-control', 'btn-secondary', 'btn-outline',\n      'text-muted', 'small', 'sr-only', 'accesshide'\n    ];\n\n    var elementClasses = (element.className || '').split(' ');\n    for (var j = 0; j < adminClasses.length; j++) {\n      if (elementClasses.indexOf(adminClasses[j]) !== -1) {\n        return true;\n      }\n    }\n\n    var text = element.textContent ? element.textContent.trim() : '';\n    if (text.length < 3) {\n      return true;\n    }\n\n    var adminWords = [\n      'edit', 'delete', 'save', 'cancel', 'ok', 'yes', 'no',\n      'settings', 'config', 'admin', 'manage', 'update',\n      'hide', 'show', 'move', 'copy', 'options', 'actions'\n    ];\n\n    if (adminWords.indexOf(text.toLowerCase()) !== -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if text content is worth translating\n   * @param {string} text - Text to analyze\n   * @returns {boolean} True if should be translated\n   */\n  function isTranslatableText(text) {\n    if (!text || text.length < 3) {\n      return false;\n    }\n\n    var normalized = normalizeTextForKey(text);\n    if (!normalized) {\n      return false;\n    }\n\n    var alphaCount = (normalized.match(/[a-zA-Z\\p{L}]/gu) || []).length;\n    if (alphaCount < normalized.length * 0.5) {\n      return false;\n    }\n\n    var commonWords = ['ok', 'id', 'url', 'api', 'css', 'js', 'html', 'php'];\n    if (commonWords.indexOf(normalized) !== -1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Extract clean text from element, handling simple HTML\n   * @param {Element} element - Element to extract text from\n   * @returns {string}\n   */\n  function extractCleanText(element) {\n    if (!element) {\n      return '';\n    }\n\n    if (element.children.length === 0) {\n      return element.textContent.trim();\n    }\n\n    var simpleFormatting = true;\n    var children = element.children;\n    for (var i = 0; i < children.length; i++) {\n      var tagName = children[i].tagName.toLowerCase();\n      if (['b', 'i', 'em', 'strong', 'span', 'small'].indexOf(tagName) === -1) {\n        simpleFormatting = false;\n        break;\n      }\n    }\n\n    if (simpleFormatting) {\n      return element.textContent.trim();\n    }\n\n    return '';\n  }\n\n  /**\n   * Generate component name from element context\n   * @param {Element} element - Element to analyze\n   * @returns {string} Component name\n   */\n  function detectComponent(element) {\n    if (!element) {\n      return 'core';\n    }\n\n    var container = element.closest('[data-region]');\n    if (container) {\n      var region = container.getAttribute('data-region');\n      if (region) {\n        return 'region_' + region;\n      }\n    }\n\n    container = element.closest('.block');\n    if (container) {\n      var blockClass = container.className.match(/block_(\\w+)/);\n      if (blockClass) {\n        return 'block_' + blockClass[1];\n      }\n    }\n\n    container = element.closest('.activity');\n    if (container) {\n      var activityClass = container.className.match(/modtype_(\\w+)/);\n      if (activityClass) {\n        return 'mod_' + activityClass[1];\n      }\n    }\n\n    if (document.body.classList.contains('path-admin')) {\n      return 'admin';\n    }\n\n    return 'core';\n  }\n\n  /**\n   * Collect meaningful class names from element (filtering dynamic/utility classes)\n   * @param {Element} element - Element to extract classes from\n   * @returns {string} Comma-separated class names\n   */\n  function collectContextClasses(element) {\n    if (!element) {\n      return '';\n    }\n\n    var blacklist = ['active', 'show', 'hide', 'hidden', 'collapsed', 'expanded', 'selected', 'current',\n      'focus', 'open', 'close', 'tooltip', 'dropdown', 'modal', 'd-flex', 'd-none', 'd-block',\n      'mt-1', 'mt-2', 'mt-3', 'mt-4', 'mt-5', 'mb-1', 'mb-2', 'mb-3', 'mb-4', 'mb-5',\n      'ml-1', 'ml-2', 'ml-3', 'ml-4', 'ml-5', 'mr-1', 'mr-2', 'mr-3', 'mr-4', 'mr-5',\n      'p-1', 'p-2', 'p-3', 'p-4', 'p-5', 'sr-only', 'visually-hidden'];\n\n    var classes = [];\n    if (element.classList) {\n      var classList = Array.prototype.slice.call(element.classList);\n      classList.forEach(function (cls) {\n        if (cls && cls.length > 2 && blacklist.indexOf(cls) === -1 &&\n          !/^[0-9]/.test(cls) && classes.indexOf(cls) === -1) {\n          classes.push(cls);\n        }\n      });\n    }\n\n    return classes.join(',');\n  }\n\n  /**\n   * Collect all data-* attributes from an element\n   * @param {Element} element - Element to extract data attributes from\n   * @returns {string} Concatenated data attribute values\n   */\n  function collectDataAttributes(element) {\n    if (!element || !element.attributes) {\n      return '';\n    }\n\n    var dataAttrs = [];\n    for (var i = 0; i < element.attributes.length; i++) {\n      var attr = element.attributes[i];\n      if (attr.name.indexOf('data-') === 0 && attr.value) {\n        // Skip data-xlate-* attributes to avoid circular references\n        if (attr.name.indexOf('data-xlate') !== 0) {\n          dataAttrs.push(attr.value);\n        }\n      }\n    }\n\n    return dataAttrs.join(',');\n  }\n\n  /**\n   * Simple hash function to create consistent 12-character keys\n   * @param {string} str - String to hash\n   * @returns {string} 12-character hash\n   */\n  function simpleHash(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n      var char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n\n    // Convert to base36 and pad/truncate to 12 chars\n    var hashStr = Math.abs(hash).toString(36);\n    if (hashStr.length < 12) {\n      hashStr = (hashStr + '000000000000').substring(0, 12);\n    } else {\n      hashStr = hashStr.substring(0, 12);\n    }\n\n    return hashStr;\n  }\n\n  /**\n   * Generate translation key from element content and context\n   * @param {Element} element - Element to generate key for\n   * @param {string} text - Text content\n   * @param {string} type - Type of content (text, placeholder, title, alt)\n   * @returns {string} Generated key (12-character hash)\n   */\n  function generateKey(element, text, type) {\n    if (!element || !text) {\n      return '';\n    }\n\n    var parts = [];\n\n    // Get parent context (one level up)\n    var parent = element.parentElement;\n    if (parent && parent.tagName) {\n      parts.push(parent.tagName.toLowerCase());\n      var parentClasses = collectContextClasses(parent);\n      if (parentClasses) {\n        parts.push(parentClasses);\n      }\n      var parentData = collectDataAttributes(parent);\n      if (parentData) {\n        parts.push(parentData);\n      }\n    }\n\n    // Get current element context\n    var tagName = element.tagName ? element.tagName.toLowerCase() : '';\n    if (tagName) {\n      parts.push(tagName);\n    }\n\n    var classes = collectContextClasses(element);\n    if (classes) {\n      parts.push(classes);\n    }\n\n    var dataAttrs = collectDataAttributes(element);\n    if (dataAttrs) {\n      parts.push(dataAttrs);\n    }\n\n    // Add type if not text\n    if (type && type !== 'text') {\n      parts.push(type);\n    }\n\n    // Add the text content\n    parts.push(text);\n\n    // Create composite string and hash it\n    var composite = parts.join('.');\n    return simpleHash(composite);\n  }\n\n  /**\n   * Auto-detect and save translatable string\n   * @param {Element} element - Element containing the string\n   * @param {string} text - Text content to save\n   * @param {string} type - Type of content (text, placeholder, title, alt)\n   */\n  function autoDetectString(element, text, type) {\n    if (!autoDetectEnabled || !text) {\n      return;\n    }\n\n    var fingerprint = createTextFingerprint(text);\n    if (!fingerprint.normalized) {\n      return;\n    }\n\n    var component = detectComponent(element);\n    var dedupeKey = component + ':' + fingerprint.normalized + ':' + type;\n    if (detectedStrings.has(dedupeKey)) {\n      return;\n    }\n    detectedStrings.add(dedupeKey);\n\n    var key = generateKey(element, text, type);\n    if (!key) {\n      return;\n    }\n\n    Ajax.call([{\n      methodname: 'local_xlate_save_key',\n      args: {\n        component: component,\n        key: key,\n        source: text,\n        lang: (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en',\n        translation: text\n      }\n    }])[0].then(function () {\n      setKeyAttribute(element, type, key);\n\n      if (window.__XLATE__) {\n        if (!window.__XLATE__.map) {\n          window.__XLATE__.map = {};\n        }\n        if (!window.__XLATE__.sourceMap) {\n          window.__XLATE__.sourceMap = {};\n        }\n        window.__XLATE__.map[key] = text;\n        window.__XLATE__.sourceMap[fingerprint.normalized] = key;\n      }\n\n      return true;\n    }).catch(function () {\n      detectedStrings.delete(dedupeKey);\n    });\n  }\n\n  /**\n   * Auto-detect translatable content in an element\n   * @param {Element} element - Element to analyze\n   */\n  function autoDetectElement(element) {\n    if (!autoDetectEnabled || !element) {\n      return;\n    }\n\n    if (shouldIgnoreElement(element)) {\n      return;\n    }\n\n    var currentLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var siteLang = (window.__XLATE__ && window.__XLATE__.siteLang) || 'en';\n\n    if (currentLang !== siteLang) {\n      return;\n    }\n\n    if (processedElements.has(element)) {\n      return;\n    }\n    processedElements.add(element);\n\n    var textContent = extractCleanText(element);\n    if (textContent && isTranslatableText(textContent)) {\n      autoDetectString(element, textContent, 'text');\n    }\n\n    ATTRIBUTE_TYPES.forEach(function (attr) {\n      if (!element.hasAttribute(attr)) {\n        return;\n      }\n      var value = element.getAttribute(attr).trim();\n      if (value && isTranslatableText(value)) {\n        autoDetectString(element, value, attr);\n      }\n    });\n  }\n\n  /**\n   * Walk the DOM depth-first and translate every eligible child.\n   * @param {Element} root Root element to process.\n   * @param {Object<string, string>} map Translation map.\n   * @returns {void}\n   */\n  function walk(root, map) {\n    if (!root) {\n      return;\n    }\n\n    var stack = [root];\n    while (stack.length) {\n      var el = stack.pop();\n      if (el.nodeType === 1) {\n        if (el.hasAttribute && el.hasAttribute('data-xlate-ignore')) {\n          continue;\n        }\n\n        translateNode(el, map);\n\n        if (autoDetectEnabled) {\n          autoDetectElement(el);\n        }\n\n        var children = el.children || [];\n        for (var i = 0; i < children.length; i++) {\n          stack.push(children[i]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Entry point: translates current DOM and observes future updates.\n   * @param {Object<string, string>} map Translation map.\n   * @returns {void}\n   */\n  function run(map) {\n    try {\n      walk(document.body, map || {});\n\n      if (autoDetectEnabled) {\n        setTimeout(function () {\n          walk(document.body, map || {});\n        }, 1000);\n\n        setTimeout(function () {\n          walk(document.body, map || {});\n        }, 3000);\n      }\n\n      var mo = new MutationObserver(function (muts) {\n        muts.forEach(function (mutation) {\n          Array.prototype.slice.call(mutation.addedNodes || []).forEach(function (node) {\n            if (node.nodeType === 1) {\n              walk(node, map || {});\n              if (node.querySelectorAll) {\n                Array.prototype.forEach.call(node.querySelectorAll('*'), function (child) {\n                  walk(child, map || {});\n                });\n              }\n            }\n          });\n        });\n      });\n      mo.observe(document.body, { childList: true, subtree: true });\n\n      if (typeof window.addEventListener === 'function') {\n        document.addEventListener('DOMContentLoaded', function () {\n          setTimeout(function () {\n            walk(document.body, map || {});\n          }, 2000);\n        });\n\n        ['focus', 'click', 'scroll'].forEach(function (eventType) {\n          document.addEventListener(eventType, function () {\n            var now = Date.now();\n            if (now - lastProcessTime > processThrottle) {\n              lastProcessTime = now;\n              setTimeout(function () {\n                walk(document.body, map || {});\n              }, 100);\n            }\n          }, true);\n        });\n      }\n    } finally {\n      document.documentElement.classList.remove('xlate-loading');\n    }\n  }\n\n  /**\n   * Initialize the translator with config from Moodle.\n   * @param {Object} config Configuration object with lang, version, bundleurl.\n   * @returns {void}\n   */\n  function init(config) {\n    document.documentElement.classList.add('xlate-loading');\n\n    if (typeof config.autodetect !== 'undefined') {\n      setAutoDetect(!(config.autodetect === false || config.autodetect === 'false'));\n    }\n\n    var k = 'xlate:' + config.lang + ':' + config.version;\n\n    window.__XLATE__ = {\n      lang: config.lang,\n      siteLang: config.siteLang,\n      map: {},\n      sourceMap: {}\n    };\n\n    /**\n     * Apply bundle data (cached or fresh) to the runtime, then translate if needed.\n     * @param {Object} bundleData Translation payload from the server/cache.\n     * @param {boolean} cached Indicates whether the payload came from localStorage.\n     * @returns {void}\n     */\n    function processBundle(bundleData, cached) {\n      if (!bundleData) {\n        return;\n      }\n\n      if (bundleData.translations) {\n        window.__XLATE__.map = bundleData.translations;\n        window.__XLATE__.sourceMap = bundleData.sourceMap || {};\n        if (!cached) {\n          run(bundleData.translations);\n        }\n      } else {\n        window.__XLATE__.map = bundleData;\n        window.__XLATE__.sourceMap = bundleData.sourceMap || {};\n        if (!cached) {\n          run(bundleData);\n        }\n      }\n    }\n\n    try {\n      var cached = localStorage.getItem(k);\n      if (cached) {\n        processBundle(JSON.parse(cached), true);\n      }\n\n      fetch(config.bundleurl, { credentials: 'same-origin' })\n        .then(function (response) {\n          return response.json();\n        })\n        .then(function (bundleData) {\n          try {\n            localStorage.setItem(k, JSON.stringify(bundleData));\n          } catch (err) {\n            // Ignore storage errors (quota, etc.)\n          }\n\n          processBundle(bundleData, false);\n          return true;\n        })\n        .catch(function () {\n          if (!cached) {\n            run({});\n          }\n        });\n    } catch (err) {\n      fetch(config.bundleurl)\n        .then(function (response) {\n          return response.json();\n        })\n        .then(function (bundle) {\n          processBundle(bundle, false);\n          return true;\n        })\n        .catch(function () {\n          run({});\n        });\n    }\n  }\n\n  /**\n   * Enable or disable automatic string detection\n   * @param {boolean} enabled - Whether to enable auto-detection\n   */\n  function setAutoDetect(enabled) {\n    autoDetectEnabled = !!enabled;\n  }\n\n  return {\n    run: run,\n    init: init,\n    setAutoDetect: setAutoDetect\n  };\n});\n"],"names":["define","Ajax","ATTRIBUTE_TYPES","autoDetectEnabled","detectedStrings","Set","processedElements","WeakSet","lastProcessTime","normalizeTextForKey","text","normalised","normalize","err","toLowerCase","replace","trim","computeHash","base","btoa","unescape","encodeURIComponent","charcodes","i","length","push","charCodeAt","toString","join","substring","toUpperCase","setKeyAttribute","element","type","key","attrType","setAttribute","getKeyFromAttributes","getAttribute","translateNode","node","map","nodeType","textContent","childNodes","normalized","window","__XLATE__","sourceMap","translationKey","forEach","attr","attrKey","value","normalisedAttr","attrTranslationKey","isTranslatableText","match","indexOf","collectContextClasses","blacklist","classes","classList","Array","prototype","slice","call","cls","test","collectDataAttributes","attributes","dataAttrs","name","generateKey","parts","parent","parentElement","tagName","parentClasses","parentData","str","hash","hashStr","Math","abs","simpleHash","autoDetectString","fingerprint","slug","words","split","slugParts","filter","part","charAt","createTextFingerprint","component","container","closest","region","blockClass","className","activityClass","document","body","contains","detectComponent","dedupeKey","has","add","methodname","args","source","lang","M","cfg","language","translation","then","catch","delete","autoDetectElement","hasAttribute","ATTR_KEY_PREFIX","LEGACY_ATTR_PREFIX","currentPath","location","pathname","adminPaths","p","adminSelectors","iSel","adminClasses","elementClasses","j","shouldIgnoreElement","siteLang","children","simpleFormatting","extractCleanText","walk","root","stack","el","pop","run","setTimeout","MutationObserver","muts","mutation","addedNodes","querySelectorAll","child","observe","childList","subtree","addEventListener","eventType","now","Date","documentElement","remove","setAutoDetect","enabled","init","config","autodetect","k","version","processBundle","bundleData","cached","translations","localStorage","getItem","JSON","parse","fetch","bundleurl","credentials","response","json","setItem","stringify","bundle"],"mappings":"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"}