{"version":3,"file":"translator.min.js","sources":["../src/translator.js"],"sourcesContent":["// Local/xlate/amd/src/translator.js\n// Handles DOM translation and automatic key capture with structural-based keys.\n//\n// WORKFLOW:\n// 1. Tag element with data-xlate-key-{type} FIRST (always)\n// 2. If currentLang === sourceLang: Save to DB (capture mode)\n// 3. If currentLang !== sourceLang: Translate using bundle\n/**\n * AMD module that detects, captures, and renders Local Xlate translations.\n *\n * Responsibilities:\n *  - Capture mode: tag DOM nodes, check existing bundle entries, persist newly\n *    discovered strings, and link keys to the active course when permitted.\n *  - Translation mode: tag DOM nodes, request a filtered bundle, apply\n *    translations, and track subsequent DOM mutations to keep content synced.\n */\ndefine(['core/ajax'], function (Ajax) {\n  var ATTR_KEY_PREFIX = 'data-xlate-key-';\n  var ATTRIBUTE_TYPES = [\n    'placeholder', 'title', 'alt', 'aria-label'\n  ];\n\n  // Auto-detection is always enabled; keys are always auto-assigned.\n  var detectedStrings = new Set();\n  var processedElements = new WeakSet();\n  var lastProcessTime = 0;\n  var processThrottle = 250;\n  var pendingTranslationKeys = new Set();\n  var requestedTranslationKeys = new Set();\n  var missingFetchTimer = null;\n  var indicatorStylesAdded = false;\n  var toggleButton = null;\n  /* Translator namespace to expose public API while keeping internal helpers private. */\n  var Translator = {};\n  Translator.utils = {};\n  Translator.keys = {};\n  Translator.attrs = {};\n  Translator.capture = {};\n  Translator.dom = {};\n  Translator.api = {};\n\n  /**\n   * Wrapper for debug logging which only emits when server-side debug is enabled.\n   * The hook in PHP will expose `window.XLATE_DEBUG` as true when Moodle debugging\n   * is set to DEVELOPER. This keeps noisy logs out of production.\n   */\n  /* eslint-disable no-console */\n  /**\n   * Debug logging helper. Emits messages only when `window.XLATE_DEBUG` is truthy.\n   * @returns {void}\n   */\n  function xlateDebug() {\n    if (typeof window !== 'undefined' && window.XLATE_DEBUG) {\n      if (typeof console !== 'undefined' && typeof console.debug === 'function') {\n        console.debug.apply(console, arguments);\n      } else if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  }\n\n  /* eslint-enable no-console */\n\n  // ============================================================================\n  // KEY GENERATION - Create structural 12-character hash keys\n  // ============================================================================\n\n  /**\n   * Collect relevant CSS classes to contribute to structural hash context.\n   * @param {Element} element - Element whose classes will be analyzed.\n   * @returns {string} Comma-separated class list used for hashing.\n   */\n  function collectContextClasses(element) {\n    if (!element || !element.classList) {\n      return '';\n    }\n\n    var blacklist = [\n      'active', 'show', 'hide', 'hidden', 'collapsed', 'expanded',\n      'd-flex', 'd-none', 'd-block', 'sr-only', 'visually-hidden'\n    ];\n    var classes = [];\n    Array.prototype.forEach.call(element.classList, function (cls) {\n      if (cls && cls.length > 2 && blacklist.indexOf(cls) === -1 &&\n        !/^[0-9]/.test(cls) && !/^[mp][tblr]?-[0-5]$/.test(cls)) {\n        classes.push(cls);\n      }\n    });\n\n    return classes.join(',');\n  }\n\n  /**\n   * Collect all non-XLATE data-* attribute values for hashing context.\n   * @param {Element} element - Element to inspect.\n   * @returns {string} Comma-separated attribute values.\n   */\n  function collectDataAttributes(element) {\n    if (!element || !element.attributes) {\n      return '';\n    }\n\n    var dataAttrs = [];\n    for (var i = 0; i < element.attributes.length; i++) {\n      var attr = element.attributes[i];\n      if (attr.name.indexOf('data-') === 0 && attr.name.indexOf('data-xlate') !== 0 && attr.value) {\n        dataAttrs.push(attr.value);\n      }\n    }\n    return dataAttrs.join(',');\n  }\n  Translator.utils.collectContextClasses = collectContextClasses;\n  Translator.utils.collectDataAttributes = collectDataAttributes;\n\n  /**\n   * Simple deterministic 12-char hash using two 32-bit accumulators (FNV-1a style + mix)\n   * Avoids constant zero padding by combining two hashes and truncating.\n   * @param {string} str - The string to hash\n   * @returns {string} 12-character base36 hash\n   */\n  function simpleHash(str) {\n    // eslint-disable-next-line no-bitwise\n    var h1 = 2166136261 >>> 0; // FNV-1a offset basis\n    // eslint-disable-next-line no-bitwise\n    var h2 = 0x9e3779b1 >>> 0; // Golden ratio constant\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charCodeAt(i);\n      // FNV-1a step on h1\n      // eslint-disable-next-line no-bitwise\n      h1 ^= c;\n      h1 = Math.imul(h1, 16777619);\n\n      // Mix on h2 (inspired by Murmur3 avalanching)\n      h2 = (h2 + c) >>> 0; // eslint-disable-line no-bitwise\n      // eslint-disable-next-line no-bitwise\n      var k = h2 ^ (h2 >>> 16);\n      h2 = Math.imul(k, 2246822507);\n      // eslint-disable-next-line no-bitwise\n      k = h2 ^ (h2 >>> 13);\n      h2 = Math.imul(k, 3266489909);\n      // eslint-disable-next-line no-bitwise\n      h2 = (h2 ^ (h2 >>> 16)) >>> 0;\n    }\n\n    // Combine and encode base36, then truncate to 12 chars\n    // eslint-disable-next-line no-bitwise\n    var s = (h1 >>> 0).toString(36) + (h2 >>> 0).toString(36);\n    if (s.length < 12) {\n      s = (s + 'qwertyuiopasdfghjklz').substring(0, 12);\n    } else if (s.length > 12) {\n      s = s.substring(0, 12);\n    }\n    return s;\n  }\n  /**\n   * Determine whether text should be considered for translation.\n   * @param {string} text - Candidate text\n   * @returns {boolean} True when text looks translatable\n   */\n  function isTranslatableText(text) {\n    if (!text || text.length < 3) {\n      return false;\n    }\n\n    var alphaCount = (text.match(/[a-zA-Z]/g) || []).length;\n    if (alphaCount < text.length * 0.3) {\n      return false;\n    }\n\n    var commonWords = ['ok', 'id', 'url', 'api'];\n    if (commonWords.indexOf(text.toLowerCase()) !== -1) {\n      return false;\n    }\n\n    return true;\n  }\n  Translator.utils.isTranslatableText = isTranslatableText;\n  Translator.utils.simpleHash = simpleHash;\n\n  /**\n   * Determine whether a translation map already contains a key.\n   * @param {Object<string,string>} map - Translation lookup table.\n   * @param {string} key - Structural key to check.\n   * @returns {boolean} True when the key exists in the map.\n   */\n  function hasTranslation(map, key) {\n    return !!(map && Object.prototype.hasOwnProperty.call(map, key));\n  }\n  Translator.utils.hasTranslation = hasTranslation;\n\n  /**\n   * Obtain direct child text content (excluding descendants) from an element.\n   * @param {Element} element - Target element.\n   * @returns {string} Direct text content.\n   */\n  function getDirectText(element) {\n    if (!element) {\n      return '';\n    }\n    var directText = '';\n    for (var i = 0; i < element.childNodes.length; i++) {\n      var node = element.childNodes[i];\n      if (node.nodeType === 3) {\n        directText += node.textContent;\n      }\n    }\n    return directText;\n  }\n\n  /**\n   * Persist the original value for an element so toggles can restore it later.\n   * @param {Element} element - Element being translated.\n   * @param {string} type - Translation type (`text` or attribute name).\n   * @returns {void}\n   */\n  function storeOriginalValue(element, type) {\n    if (!element) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    var dataAttr = 'data-xlate-original-' + attrType;\n    if (element.hasAttribute(dataAttr)) {\n      return;\n    }\n    var original = '';\n    if (type === 'text') {\n      original = getDirectText(element);\n    } else {\n      original = element.getAttribute(type) || '';\n    }\n    element.setAttribute(dataAttr, original);\n  }\n\n  /**\n   * Restore the previously stored original value for an element.\n   * @param {Element} element - Element to restore.\n   * @param {string} type - Translation type (`text` or attribute name).\n   * @returns {void}\n   */\n  function restoreOriginalValue(element, type) {\n    if (!element) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    var dataAttr = 'data-xlate-original-' + attrType;\n    if (!element.hasAttribute(dataAttr)) {\n      return;\n    }\n    var original = element.getAttribute(dataAttr) || '';\n    if (type === 'text') {\n      element.textContent = original;\n    } else {\n      element.setAttribute(type, original);\n    }\n  }\n\n  /**\n   * Determine whether translations should currently be displayed.\n   * @returns {boolean} True when translation overlay is enabled.\n   */\n  function shouldShowTranslations() {\n    if (!window.__XLATE__) {\n      return true;\n    }\n    return window.__XLATE__.showTranslations !== false;\n  }\n\n  /**\n   * Check if a translation key has been human-reviewed.\n   * @param {string} key - Structural translation key.\n   * @returns {boolean} True when the key is marked reviewed.\n   */\n  function isKeyReviewed(key) {\n    if (!window.__XLATE__ || !window.__XLATE__.reviewMap) {\n      return true;\n    }\n    var flag = window.__XLATE__.reviewMap[key];\n    return flag === 1 || flag === '1' || flag === true;\n  }\n\n  /**\n   * Toggle the inline auto-translation indicator for a given element.\n   * @param {Element} element - Host element for the indicator.\n   * @param {string} key - Translation key (used for state tracking).\n   * @param {boolean} show - Whether to display the indicator.\n   * @returns {void}\n   */\n  function toggleAutoIndicator(element, key, show) {\n    if (!element || typeof element !== 'object') {\n      return;\n    }\n    if (!show) {\n      if (element.__xlateIndicator && element.__xlateIndicator.remove) {\n        element.__xlateIndicator.remove();\n      }\n      element.__xlateIndicator = null;\n      return;\n    }\n\n    if (element.__xlateIndicator) {\n      return;\n    }\n\n    ensureIndicatorStyles();\n\n    var indicator = document.createElement('span');\n    indicator.className = 'xlate-auto-indicator icon fa fa-globe text-muted';\n    indicator.setAttribute('role', 'img');\n    indicator.setAttribute('aria-label', 'AI translated');\n    indicator.setAttribute('title', 'AI translated');\n    indicator.setAttribute('data-xlate-indicator', key || '');\n\n    if (typeof element.appendChild === 'function') {\n      element.appendChild(indicator);\n    }\n\n    element.__xlateIndicator = indicator;\n  }\n\n  /**\n   * Inject the inline styles required for indicators and toggle control.\n   * @returns {void}\n   */\n  function ensureIndicatorStyles() {\n    if (indicatorStylesAdded) {\n      return;\n    }\n    indicatorStylesAdded = true;\n    var style = document.createElement('style');\n    style.setAttribute('data-xlate-style', 'indicator');\n    style.textContent = '' +\n      '.xlate-auto-indicator {' +\n      '  display:inline-flex;' +\n      '  align-items:center;' +\n      '  font-size:0.75em;' +\n      '  margin-left:0.35em;' +\n      '  opacity:0.75;' +\n      '}' +\n      '.xlate-auto-toggle {' +\n      '  position:fixed;' +\n      '  right:1rem;' +\n      '  bottom:1rem;' +\n      '  z-index:1040;' +\n      '}' +\n      '.xlate-auto-toggle .icon {' +\n      '  margin-right:0.35em;' +\n      '}';\n    document.head.appendChild(style);\n  }\n\n  /**\n   * Update the toggle button label to reflect current mode.\n   * @returns {void}\n   */\n  function updateToggleButtonLabel() {\n    if (!toggleButton) {\n      return;\n    }\n    var enabled = shouldShowTranslations();\n    var label = enabled ? 'Hide AI translations' : 'Show AI translations';\n    toggleButton.innerHTML = '<span class=\"icon fa fa-language\" aria-hidden=\"true\"></span>' + label;\n    toggleButton.setAttribute('aria-pressed', enabled ? 'true' : 'false');\n    toggleButton.setAttribute('title', label);\n  }\n\n  /**\n   * Handle user toggling AI translation display.\n   * @param {Event} e - Click event instance.\n   * @returns {void}\n   */\n  function handleToggleClick(e) {\n    if (e) {\n      e.preventDefault();\n    }\n    if (!window.__XLATE__) {\n      return;\n    }\n    window.__XLATE__.showTranslations = !shouldShowTranslations();\n    updateToggleButtonLabel();\n    processedElements = new WeakSet();\n    walk(document.body, window.__XLATE__.map || {}, false);\n  }\n\n  /**\n   * Ensure the floating toggle control is present for translation mode.\n   * @returns {void}\n   */\n  function ensureToggleControl() {\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n    ensureIndicatorStyles();\n    if (toggleButton) {\n      return;\n    }\n    toggleButton = document.createElement('button');\n    toggleButton.type = 'button';\n    toggleButton.className = 'btn btn-light btn-sm xlate-auto-toggle';\n    toggleButton.addEventListener('click', handleToggleClick);\n    document.body.appendChild(toggleButton);\n    updateToggleButtonLabel();\n  }\n\n  /**\n   * Generate translation key from element structure + direct text (ignoring children)\n   * @param {Element} element - The element to generate key for\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string} 12-character hash key\n   */\n  function generateKey(element, text, type) {\n    if (!element || !text) {\n      return '';\n    }\n\n    var parts = [];\n\n    // Parent context\n    var parent = element.parentElement;\n    if (parent && parent.tagName) {\n      parts.push(parent.tagName.toLowerCase());\n      var parentClasses = collectContextClasses(parent);\n      if (parentClasses) {\n        parts.push(parentClasses);\n      }\n      var parentData = collectDataAttributes(parent);\n      if (parentData) {\n        parts.push(parentData);\n      }\n    }\n\n    // Current element context\n    if (element.tagName) {\n      parts.push(element.tagName.toLowerCase());\n    }\n    var classes = collectContextClasses(element);\n    if (classes) {\n      parts.push(classes);\n    }\n    var dataAttrs = collectDataAttributes(element);\n    if (dataAttrs) {\n      parts.push(dataAttrs);\n    }\n\n    // Type and direct text only (ignore children)\n    if (type && type !== 'text') {\n      parts.push(type);\n    }\n    // Get only direct text nodes (ignore children)\n    var directText = '';\n    for (var i = 0; i < element.childNodes.length; i++) {\n      var node = element.childNodes[i];\n      if (node.nodeType === 3) { // TEXT_NODE\n        directText += node.textContent;\n      }\n    }\n    directText = directText.trim();\n    parts.push(directText);\n\n    return simpleHash(parts.join('.'));\n  }\n  Translator.keys.generateKey = generateKey;\n  Translator.keys.generateKey = generateKey;\n\n  // ============================================================================\n  // KEY ATTRIBUTE MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Set data-xlate-key-{type} attribute\n   * @param {Element} element - The element to set attribute on\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The key value\n   */\n  function setKeyAttribute(element, type, key) {\n    if (!element || !key) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    element.setAttribute(ATTR_KEY_PREFIX + attrType, key);\n  }\n  Translator.attrs.setKeyAttribute = setKeyAttribute;\n  Translator.attrs.setKeyAttribute = setKeyAttribute;\n\n  /**\n   * Get data-xlate-key-{type} attribute\n   * @param {Element} element - The element to get attribute from\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string|null} The key value\n   */\n  function getKeyFromAttributes(element, type) {\n    if (!element) {\n      return null;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    return element.getAttribute(ATTR_KEY_PREFIX + attrType);\n  }\n  Translator.attrs.getKeyFromAttributes = getKeyFromAttributes;\n  Translator.attrs.getKeyFromAttributes = getKeyFromAttributes;\n\n  // ============================================================================\n  // TRANSLATION (Step 3: currentLang !== sourceLang)\n  // ============================================================================\n\n  /**\n   * Translate element using bundle\n   * @param {Element} element - The element to translate\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {Object} map - The translation map\n   */\n  function translateElement(element, type, map) {\n    var key = getKeyFromAttributes(element, type);\n    if (!key) {\n      return;\n    }\n\n    storeOriginalValue(element, type);\n\n    if (!shouldShowTranslations()) {\n      restoreOriginalValue(element, type);\n      if (type === 'text') {\n        toggleAutoIndicator(element, key, false);\n      }\n      return;\n    }\n\n    if (!map || !hasTranslation(map, key)) {\n      if (type === 'text') {\n        toggleAutoIndicator(element, key, false);\n      }\n      return;\n    }\n\n    var value = map[key];\n    if (typeof value !== 'string') {\n      return;\n    }\n\n    if (type === 'text') {\n      element.textContent = value;\n      toggleAutoIndicator(element, key, !isKeyReviewed(key));\n    } else {\n      element.setAttribute(type, value);\n    }\n  }\n  /**\n   * Translate a single element using the provided translation map.\n   * @param {Element} element - Element to translate\n   * @param {string} type - Type of translation (text, placeholder, etc)\n   * @param {Object} map - Translation map keyed by generated keys\n   */\n  Translator.capture.translateElement = translateElement;\n  Translator.capture.translateElement = translateElement;\n\n  // ============================================================================\n  // CAPTURE (Step 2: currentLang === sourceLang)\n  // ============================================================================\n\n  /**\n   * Detect component from element context\n   * @param {Element} element - The element to detect component for\n   * @returns {string} Component name\n   */\n  function detectComponent(element) {\n    if (!element) {\n      return 'core';\n    }\n\n    var container = element.closest('[data-region]');\n    if (container) {\n      var region = container.getAttribute('data-region');\n      if (region) {\n        return 'region_' + region;\n      }\n    }\n\n    container = element.closest('.block');\n    if (container) {\n      var blockClass = container.className.match(/block_(\\w+)/);\n      if (blockClass) {\n        return 'block_' + blockClass[1];\n      }\n    }\n\n    if (document.body.classList.contains('path-admin')) {\n      return 'admin';\n    }\n\n    return 'core';\n  }\n  /**\n   * Save new key and source text to the backend via Ajax.\n   * @param {Element} element - Source element\n   * @param {string} text - Source text to save\n   * @param {string} type - The attribute/type (text, placeholder, ...)\n   * @param {string} key - Generated structural key\n   * @param {Object} existingMap - Optional map to avoid saving existing keys\n   */\n  Translator.capture.detectComponent = detectComponent;\n  Translator.capture.detectComponent = detectComponent;\n\n  /**\n   * Save translatable string to database\n   * @param {Element} element - The element being saved\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The generated key\n   * @param {Object} existingMap - Optional bundle map to check before saving\n   */\n  function saveToDatabase(element, text, type, key, existingMap) {\n    // If key already exists in the bundle, skip saving\n    if (existingMap && existingMap[key]) {\n      xlateDebug('[XLATE] Skipping save - key exists:', key);\n      return;\n    }\n\n    var component = detectComponent(element);\n    var dedupeKey = component + ':' + key + ':' + type;\n\n    if (detectedStrings.has(dedupeKey)) {\n      return;\n    }\n    detectedStrings.add(dedupeKey);\n\n    xlateDebug('[XLATE] Saving new key:', key, 'component:', component, 'text:', text.substring(0, 50));\n\n    // Determine page-level course id (prefer server-injected XLATE_COURSEID when present)\n    var pageCourseId = 0;\n    if (typeof window !== 'undefined' && typeof window.XLATE_COURSEID !== 'undefined') {\n      pageCourseId = window.XLATE_COURSEID;\n    } else if (typeof M !== 'undefined' && M.cfg && M.cfg.courseid) {\n      pageCourseId = M.cfg.courseid;\n    }\n\n    var curLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var sourceLang = (window.__XLATE__ && window.__XLATE__.sourceLang) ||\n      (window.__XLATE__ && window.__XLATE__.captureSourceLang) || 'en';\n    var reviewedFlag = (curLang === sourceLang) ? 1 : 0;\n\n    Ajax.call([{\n      methodname: 'local_xlate_save_key',\n      args: {\n        component: component,\n        key: key,\n        source: text,\n        lang: curLang,\n        translation: text,\n        // If the current page language equals the configured source, mark\n        // captured source strings as reviewed (human-authored content).\n        reviewed: reviewedFlag,\n        courseid: pageCourseId,\n        context: component\n      }\n    }])[0].then(function () {\n      if (window.__XLATE__) {\n        if (!window.__XLATE__.map) {\n          window.__XLATE__.map = {};\n        }\n        window.__XLATE__.map[key] = text;\n        if (!window.__XLATE__.reviewMap) {\n          window.__XLATE__.reviewMap = {};\n        }\n        window.__XLATE__.reviewMap[key] = 1;\n      }\n      return true;\n    }).catch(function () {\n      detectedStrings.delete(dedupeKey);\n    });\n  }\n  Translator.capture.saveToDatabase = saveToDatabase;\n  Translator.capture.saveToDatabase = saveToDatabase;\n\n  // ============================================================================\n  // ELEMENT PROCESSING (Step 1: Tag FIRST)\n  // ============================================================================\n\n  /**\n   * Check if element should be ignored\n   * @param {Element} element - The element to check\n   * @returns {boolean} True if should be ignored\n   */\n  function shouldIgnoreElement(element) {\n    if (!element || !element.tagName) {\n      return true;\n    }\n\n    var tagName = element.tagName.toLowerCase();\n    if ([\n      'script', 'style', 'meta', 'link', 'noscript', 'head'\n    ].indexOf(tagName) !== -1) {\n      return true;\n    }\n\n    // Exclude selectors from settings (window.XLATE_EXCLUDE_SELECTORS)\n    if (window.XLATE_EXCLUDE_SELECTORS && Array.isArray(window.XLATE_EXCLUDE_SELECTORS)) {\n      for (var i = 0; i < window.XLATE_EXCLUDE_SELECTORS.length; i++) {\n        var sel = window.XLATE_EXCLUDE_SELECTORS[i];\n        if (!sel) {\n          continue;\n        }\n        try {\n          if (element.matches(sel) || (element.closest && element.closest(sel))) {\n            return true;\n          }\n        } catch (e) {\n          xlateDebug('[XLATE][DEBUG] Invalid selector:', sel, e);\n        }\n      }\n    }\n\n    if (element.hasAttribute('data-xlate-ignore') || element.closest('[data-xlate-ignore]')) {\n      return true;\n    }\n\n    // Do not skip elements just because they already have key attributes;\n    // we rely on processedElements to prevent duplicate work.\n\n    // Admin paths stay blocked to avoid capturing config screens where translators do not run.\n    var currentPath = window.location.pathname || '';\n    var adminPaths = ['/admin/', '/local/xlate/', '/course/modedit.php'];\n    for (var p = 0; p < adminPaths.length; p++) {\n      if (currentPath.indexOf(adminPaths[p]) === 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  Translator.dom.shouldIgnoreElement = shouldIgnoreElement;\n\n\n  /**\n   * Collect any data-xlate-key-* attribute values from an element into a set-like object\n   * @param {Element} el - Element to inspect\n   * @param {Object} keySet - Object used as a set to store keys\n   */\n  function collectKeysFromElement(el, keySet) {\n    var attrs = el && el.attributes;\n    if (!attrs) {\n      return;\n    }\n    for (var j = 0; j < attrs.length; j++) {\n      var a = attrs[j];\n      var name = a && a.name;\n      if (name && name.indexOf(ATTR_KEY_PREFIX) === 0) {\n        var val = a.value;\n        if (val) {\n          keySet[val] = true;\n        }\n      }\n    }\n  }\n  /**\n   * Process a candidate value for translation or capture.\n   * @param {Element} element - Element being processed.\n   * @param {string} value - Source text or attribute value.\n   * @param {string} attrName - Attribute name ('text' for text nodes).\n   * @param {boolean} tagOnly - Whether we are in tag-only mode.\n   * @param {boolean} isCapture - Whether capture mode is active.\n   * @param {Object} map - Translation map.\n   * @returns {void}\n   */\n  function processCandidateValue(element, value, attrName, tagOnly, isCapture, map) {\n    if (!value || !isTranslatableText(value)) {\n      return;\n    }\n\n    var key = generateKey(element, value, attrName);\n    if (!key) {\n      return;\n    }\n\n    setKeyAttribute(element, attrName, key);\n\n    if (tagOnly) {\n      return;\n    }\n\n    if (isCapture) {\n      saveToDatabase(element, value, attrName, key, map);\n      return;\n    }\n\n    if (!map) {\n      return;\n    }\n\n    if (hasTranslation(map, key)) {\n      translateElement(element, attrName, map);\n      return;\n    }\n\n    queueMissingTranslation(key);\n  }\n\n  /**\n   * Process a single DOM element: tag, then optionally save or translate.\n   * @param {Element} element - Element to process\n   * @param {Object} map - Translation map\n   * @param {boolean} tagOnly - When true, only add key attributes\n   */\n  function processElement(element, map, tagOnly) {\n    if (shouldIgnoreElement(element) || processedElements.has(element)) {\n      return;\n    }\n    processedElements.add(element);\n\n    var currentLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var sourceLang = (window.__XLATE__ && window.__XLATE__.sourceLang) ||\n      (window.__XLATE__ && window.__XLATE__.captureSourceLang) || 'en';\n    var isCapture = (currentLang === sourceLang);\n\n    // For block-level elements, capture innerHTML to preserve inline tags\n    var blockTags = ['p', 'li', 'td', 'th', 'blockquote', 'dt', 'dd', 'figcaption'];\n    var tag = element.tagName ? element.tagName.toLowerCase() : '';\n    var sourceText;\n    if (blockTags.indexOf(tag) !== -1) {\n      sourceText = element.innerHTML.trim();\n    } else {\n      // Fallback: direct text only for inline/other elements\n      sourceText = '';\n      for (var i = 0; i < element.childNodes.length; i++) {\n        var node = element.childNodes[i];\n        if (node.nodeType === 3) { // TEXT_NODE\n          sourceText += node.textContent;\n        }\n      }\n      sourceText = sourceText.trim();\n    }\n    processCandidateValue(element, sourceText, 'text', tagOnly, isCapture, map);\n\n    // Process attributes\n    ATTRIBUTE_TYPES.forEach(function (attr) {\n      if (!element.hasAttribute(attr)) {\n        return;\n      }\n      var value = element.getAttribute(attr).trim();\n      processCandidateValue(element, value, attr, tagOnly, isCapture, map);\n    });\n  }\n  Translator.dom.collectKeysFromElement = collectKeysFromElement;\n\n  /**\n   * Debounced trigger that batches pending keys and requests translations.\n   * @returns {void}\n   */\n  function scheduleMissingFetch() {\n    if (missingFetchTimer !== null) {\n      return;\n    }\n    missingFetchTimer = window.setTimeout(function () {\n      missingFetchTimer = null;\n      if (!pendingTranslationKeys || pendingTranslationKeys.size === 0) {\n        return;\n      }\n      var keys = [];\n      pendingTranslationKeys.forEach(function (k) {\n        keys.push(k);\n      });\n      pendingTranslationKeys.clear();\n      fetchMissingTranslations(keys);\n    }, 200);\n  }\n\n  /**\n   * Mark keys as requested to avoid duplicate fetching.\n   * @param {Array<string>} keys - Keys to record.\n   * @returns {void}\n   */\n  function markKeysAsRequested(keys) {\n    keys.forEach(function (k) {\n      requestedTranslationKeys.add(k);\n    });\n  }\n\n  /**\n   * Remove keys from requested set after a failed fetch.\n   * @param {Array<string>} keys - Keys to remove.\n   * @returns {void}\n   */\n  function unmarkRequestedKeys(keys) {\n    keys.forEach(function (k) {\n      requestedTranslationKeys.delete(k);\n    });\n  }\n\n  /**\n   * Merge new translations into the provided map.\n   * @param {Object} map - Existing translation map.\n   * @param {Object} translations - Incoming translations.\n   * @returns {boolean} True when at least one entry changed.\n   */\n  function mergeTranslationsIntoMap(map, translations) {\n    var updated = false;\n    Object.keys(translations).forEach(function (k) {\n      var value = translations[k];\n      if (!Object.prototype.hasOwnProperty.call(map, k) || map[k] !== value) {\n        map[k] = value;\n        updated = true;\n      }\n    });\n    return updated;\n  }\n\n  /**\n   * Ensure the global review map exists and merge incoming flags.\n   * @param {Object|null} reviewUpdates - Incoming review flags.\n   * @returns {boolean} True when any review flag changed.\n   */\n  function applyReviewUpdates(reviewUpdates) {\n    if (!reviewUpdates || typeof reviewUpdates !== 'object') {\n      return false;\n    }\n\n    if (!window.__XLATE__.reviewMap) {\n      window.__XLATE__.reviewMap = {};\n    }\n\n    var reviewChanged = false;\n    Object.keys(reviewUpdates).forEach(function (k) {\n      var incoming = reviewUpdates[k];\n      if (window.__XLATE__.reviewMap[k] !== incoming) {\n        reviewChanged = true;\n      }\n      window.__XLATE__.reviewMap[k] = incoming;\n    });\n\n    return reviewChanged;\n  }\n\n  /**\n   * Persist the latest translations and review map to local storage cache.\n   * @param {Object} translations - Newly received translations.\n   * @returns {void}\n   */\n  function syncCacheWithLatest(translations) {\n    if (!window.__XLATE__.cacheKey) {\n      return;\n    }\n\n    try {\n      var cached = localStorage.getItem(window.__XLATE__.cacheKey);\n      var cachedPayload = cached ? JSON.parse(cached) : null;\n      var cachedTranslations;\n      var cachedReviewed;\n\n      if (cachedPayload && typeof cachedPayload === 'object' && cachedPayload.translations) {\n        cachedTranslations = cachedPayload.translations;\n        cachedReviewed = cachedPayload.reviewed || {};\n      } else if (cachedPayload && typeof cachedPayload === 'object' && !Array.isArray(cachedPayload)) {\n        cachedTranslations = cachedPayload;\n        cachedReviewed = {};\n      } else {\n        cachedTranslations = {};\n        cachedReviewed = {};\n      }\n\n      Object.keys(translations).forEach(function (k) {\n        cachedTranslations[k] = translations[k];\n      });\n\n      var reviewMap = window.__XLATE__.reviewMap || {};\n      Object.keys(reviewMap).forEach(function (k) {\n        cachedReviewed[k] = reviewMap[k];\n      });\n\n      localStorage.setItem(window.__XLATE__.cacheKey, JSON.stringify({\n        translations: cachedTranslations,\n        reviewed: cachedReviewed\n      }));\n    } catch (e) {\n      // Ignore cache sync errors.\n    }\n  }\n\n  /**\n   * Request translations for keys discovered after the initial bundle load.\n   * @param {Array<string>} keys - Structural keys requiring translations.\n   * @returns {void}\n   */\n  function fetchMissingTranslations(keys) {\n    if (!keys || !keys.length) {\n      return;\n    }\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n\n    var bundleUrl = window.__XLATE__.bundleUrl || '';\n    if (!bundleUrl) {\n      return;\n    }\n\n    fetch(bundleUrl, {\n      method: 'POST',\n      credentials: 'same-origin',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ keys: keys })\n    })\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (data) {\n        var map = window.__XLATE__.map || {};\n        var translations = (data && data.translations) ? data.translations : data;\n        if (!translations || typeof translations !== 'object') {\n          markKeysAsRequested(keys);\n          return null;\n        }\n\n        var updated = mergeTranslationsIntoMap(map, translations);\n        var reviewChanged = applyReviewUpdates(data && data.reviewed ? data.reviewed : null);\n\n        if (updated || reviewChanged) {\n          window.__XLATE__.map = map;\n          syncCacheWithLatest(translations);\n\n          processedElements = new WeakSet();\n          walk(document.body, map, false);\n        }\n\n        markKeysAsRequested(keys);\n        return null;\n      })\n      .catch(function (err) {\n        unmarkRequestedKeys(keys);\n        xlateDebug('[XLATE] Missing translation fetch failed', err);\n        return null;\n      });\n  }\n\n  /**\n   * Queue a translation key for deferred fetching if it is not already pending.\n   * @param {string} key - Structural key needing translation.\n   * @returns {void}\n   */\n  function queueMissingTranslation(key) {\n    if (!key || pendingTranslationKeys.has(key) || requestedTranslationKeys.has(key)) {\n      return;\n    }\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n    pendingTranslationKeys.add(key);\n    scheduleMissingFetch();\n  }\n  Translator.dom.processElement = processElement;\n\n  // ============================================================================\n  // DOM WALKING\n  // ============================================================================\n\n  /**\n   * Walk DOM and process elements\n   * @param {Element} root - Root element to start from\n   * @param {Object} map - The translation map\n   * @param {boolean} tagOnly - When true, only tag keys without saving/translating\n   */\n  function walk(root, map, tagOnly) {\n    if (!root) {\n      return;\n    }\n\n    // If capture selectors are set, only walk those areas\n    var captureSelectors = (window.XLATE_CAPTURE_SELECTORS &&\n      Array.isArray(window.XLATE_CAPTURE_SELECTORS) &&\n      window.XLATE_CAPTURE_SELECTORS.length)\n      ? window.XLATE_CAPTURE_SELECTORS : null;\n\n    var roots = [];\n    if (captureSelectors) {\n      captureSelectors.forEach(function (sel) {\n        try {\n          var found = document.querySelectorAll(sel);\n          for (var i = 0; i < found.length; i++) {\n            roots.push(found[i]);\n          }\n        } catch (e) { /* Ignore invalid selectors */ }\n      });\n      if (!roots.length) {\n        roots = [root]; // Fallback to body\n      }\n    } else {\n      roots = [root];\n    }\n\n    roots.forEach(function (scanRoot) {\n      var stack = [scanRoot];\n      while (stack.length) {\n        var el = stack.pop();\n        if (el.nodeType === 1) {\n          // If this element should be ignored (exclusion zone), skip its subtree\n          if (shouldIgnoreElement(el)) {\n            continue;\n          }\n          processElement(el, map, tagOnly);\n          var children = el.children || [];\n          for (var i = 0; i < children.length; i++) {\n            stack.push(children[i]);\n          }\n        }\n      }\n    });\n  }\n  Translator.dom.walk = walk;\n  Translator.dom.walk = walk;\n\n  /**\n   * Run translator\n   * @param {Object<string,string>} map Translation map keyed by structural hash.\n   * @returns {void}\n   */\n  function run(map) {\n    try {\n      walk(document.body, map || {});\n      if (window.__XLATE__ && !window.__XLATE__.isCapture) {\n        ensureToggleControl();\n      }\n\n      // Fallback: periodic refreshes to catch late-injected content\n      setTimeout(function () {\n        walk(document.body, map || {});\n        if (window.__XLATE__ && !window.__XLATE__.isCapture) {\n          ensureToggleControl();\n        }\n      }, 1000);\n      setTimeout(function () {\n        walk(document.body, map || {});\n        if (window.__XLATE__ && !window.__XLATE__.isCapture) {\n          ensureToggleControl();\n        }\n      }, 3000);\n      setTimeout(function () {\n        walk(document.body, map || {});\n        if (window.__XLATE__ && !window.__XLATE__.isCapture) {\n          ensureToggleControl();\n        }\n      }, 6000);\n\n      var mo = new MutationObserver(function (muts) {\n        muts.forEach(function (mutation) {\n          Array.prototype.slice.call(mutation.addedNodes || []).forEach(function (node) {\n            if (node.nodeType === 1) {\n              walk(node, map || {});\n            }\n          });\n        });\n      });\n      mo.observe(document.body, { childList: true, subtree: true });\n\n      if (typeof window.addEventListener === 'function') {\n        ['focus', 'click', 'scroll'].forEach(function (eventType) {\n          document.addEventListener(eventType, function () {\n            var now = Date.now();\n            if (now - lastProcessTime > processThrottle) {\n              lastProcessTime = now;\n              setTimeout(function () {\n                walk(document.body, map || {});\n                if (window.__XLATE__ && !window.__XLATE__.isCapture) {\n                  ensureToggleControl();\n                }\n              }, 100);\n            }\n          }, true);\n        });\n      }\n    } finally {\n      document.documentElement.classList.remove('xlate-loading');\n    }\n  }\n  Translator.api.run = run;\n\n  /**\n   * Get source value for an element based on the key attribute type.\n   * @param {Element} el - Element to inspect\n   * @param {string} typename - Attribute type (content for text)\n   * @returns {string} Source value or empty string\n   */\n  function getSourceForElementAttr(el, typename) {\n    if (!el) {\n      return '';\n    }\n    if (typename === 'content') {\n      var dt = '';\n      for (var dn = 0; dn < el.childNodes.length; dn++) {\n        var node = el.childNodes[dn];\n        if (node.nodeType === 3) {\n          dt += node.textContent;\n        }\n      }\n      return dt.trim();\n    }\n    try {\n      return el.getAttribute(typename) || '';\n    } catch (e) {\n      return '';\n    }\n  }\n\n  /**\n   * Collect key set and first-seen details (component + source) for keys under root.\n   * @param {Element} root - Root to scan\n   * @returns {Object} {keySet: {}, keyDetails: {}}\n   */\n  function collectKeySetAndDetails(root) {\n    var keySet = {};\n    var keyDetails = {};\n    var all = (root && root.querySelectorAll) ? root.querySelectorAll('*') : [];\n    for (var i = 0; i < all.length; i++) {\n      var el = all[i];\n      collectKeysFromElement(el, keySet);\n      var attrs = el && el.attributes;\n      if (!attrs) {\n        continue;\n      }\n      for (var j = 0; j < attrs.length; j++) {\n        var attrname = attrs[j] && attrs[j].name;\n        if (!attrname || attrname.indexOf(ATTR_KEY_PREFIX) !== 0) {\n          continue;\n        }\n        var aval = attrs[j].value;\n        if (!aval) {\n          continue;\n        }\n        if (keyDetails[aval]) {\n          continue;\n        }\n        var typename = attrname.substring(ATTR_KEY_PREFIX.length);\n        var src = getSourceForElementAttr(el, typename);\n        keyDetails[aval] = {\n          component: detectComponent(el),\n          source: src\n        };\n      }\n    }\n    return { keySet: keySet, keyDetails: keyDetails };\n  }\n\n  /**\n   * Create the base XLATE state object from configuration.\n   * @param {TranslatorConfig} config - Translator configuration.\n   * @returns {Object} Base state object.\n   */\n  function createXlateState(config) {\n    var resolvedSourceLang = config.sourceLang || config.captureSourceLang || config.lang || 'en';\n    var targetLangs = Array.isArray(config.targetLangs) ? config.targetLangs : [];\n    var enabledLangs = Array.isArray(config.enabledLangs) ? config.enabledLangs : [];\n\n    var state = {\n      lang: config.lang,\n      sourceLang: resolvedSourceLang,\n      captureSourceLang: config.captureSourceLang || resolvedSourceLang,\n      targetLangs: targetLangs,\n      enabledLangs: enabledLangs,\n      map: {},\n      sourceMap: {},\n      reviewMap: {},\n      bundleUrl: config.bundleurl || '',\n      version: config.version || '',\n      cacheKey: ''\n    };\n\n    state.isCapture = (config.lang === state.captureSourceLang);\n    state.isTargetLang = !state.targetLangs.length || state.targetLangs.indexOf(config.lang) !== -1;\n    return state;\n  }\n\n  /**\n   * Resolve the active course id exposed to the page, if any.\n   * @returns {number|null} Course id or null when unavailable.\n   */\n  function resolveCourseId() {\n    if (typeof window !== 'undefined' && typeof window.XLATE_COURSEID !== 'undefined') {\n      return window.XLATE_COURSEID;\n    }\n\n    if (typeof M !== 'undefined' && M.cfg && M.cfg.courseid) {\n      return M.cfg.courseid;\n    }\n\n    return null;\n  }\n\n  /**\n   * Associate keys with a course when the backend provides association metadata.\n   * @param {Array<string>} keys - Keys collected from DOM.\n   * @param {Object} keyDetails - Per-key detail map.\n   * @param {Object} associations - Associations returned from bundle.\n   * @param {number|null} courseId - Course id when available.\n   * @returns {void}\n   */\n  function associateKeysWithCourse(keys, keyDetails, associations, courseId) {\n    if (!courseId || !associations || typeof associations !== 'object') {\n      return;\n    }\n\n    var toAssociate = [];\n    for (var ti = 0; ti < keys.length; ti++) {\n      var key = keys[ti];\n      if (!associations[key]) {\n        var detail = keyDetails[key] || null;\n        if (detail) {\n          toAssociate.push({\n            component: detail.component,\n            key: key,\n            source: detail.source || ''\n          });\n        }\n      }\n    }\n\n    if (!toAssociate.length) {\n      return;\n    }\n\n    xlateDebug('[XLATE] Associating', toAssociate.length, 'keys with course', courseId);\n    try {\n      Ajax.call([{\n        methodname: 'local_xlate_associate_keys',\n        args: {\n          keys: toAssociate,\n          courseid: courseId,\n          context: ''\n        }\n      }]);\n    } catch (e) {\n      xlateDebug('[XLATE] Bulk-associate exception', e);\n    }\n  }\n\n  /**\n   * Hydrate cached translations for translation mode.\n   * @param {string} cacheKey - Cache key identifier.\n   * @returns {{translations:Object, reviewed:Object}|null} Cached payload when available.\n   */\n  function readCachedBundle(cacheKey) {\n    if (!cacheKey) {\n      return null;\n    }\n\n    try {\n      var cached = localStorage.getItem(cacheKey);\n      if (!cached) {\n        return null;\n      }\n      var payload = JSON.parse(cached);\n      if (!payload || typeof payload !== 'object') {\n        return null;\n      }\n\n      if (payload.translations && typeof payload.translations === 'object') {\n        return {\n          translations: payload.translations,\n          reviewed: payload.reviewed || {}\n        };\n      }\n\n      if (!Array.isArray(payload)) {\n        return {\n          translations: payload,\n          reviewed: {}\n        };\n      }\n    } catch (e) {\n      return null;\n    }\n\n    return null;\n  }\n\n  /**\n   * Handle capture-mode initialization logic.\n   * @param {TranslatorConfig} config - Translator configuration.\n   * @param {number|null} courseId - Active course id, if any.\n   * @returns {void}\n   */\n  function initCaptureMode(config, courseId) {\n    xlateDebug('[XLATE] Capture mode - starting tag-only pass');\n    processedElements = new WeakSet();\n    walk(document.body, {}, true);\n\n    var collected = collectKeySetAndDetails(document);\n    var keySetCap = collected.keySet;\n    var keyDetails = collected.keyDetails;\n    var keysCap = Object.keys(keySetCap);\n\n    xlateDebug('[XLATE] Collected', keysCap.length, 'keys from DOM');\n\n    if (!keysCap.length) {\n      xlateDebug('[XLATE] No keys found, skipping bundle fetch');\n      run({});\n      return;\n    }\n\n    xlateDebug('[XLATE] Fetching bundle to check existing keys...');\n    fetch(config.bundleurl, {\n      method: 'POST',\n      credentials: 'same-origin',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ keys: keysCap })\n    })\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (map) {\n        var translations = (map && map.translations) ? map.translations : map;\n        var sourceMap = (map && map.sourceMap) ? map.sourceMap : {};\n        var reviewMap = (map && map.reviewed && typeof map.reviewed === 'object') ? map.reviewed : {};\n        var associations = (map && map.associations) ? map.associations : {};\n        if (!translations || typeof translations !== 'object') {\n          translations = {};\n        }\n        window.__XLATE__.map = translations;\n        window.__XLATE__.sourceMap = sourceMap;\n        window.__XLATE__.reviewMap = reviewMap;\n\n        var existingCount = Object.keys(translations).length;\n        xlateDebug('[XLATE] Bundle returned', existingCount, 'existing translations');\n\n        associateKeysWithCourse(keysCap, keyDetails, associations, courseId);\n\n        processedElements = new WeakSet();\n        walk(document.body, translations, false);\n        run(translations);\n        return true;\n      })\n      .catch(function (err) {\n        xlateDebug('[XLATE] Bundle fetch failed:', err);\n        processedElements = new WeakSet();\n        walk(document.body, {}, false);\n        run({});\n      });\n  }\n\n  /**\n   * Handle translation-mode initialization logic.\n   * @param {TranslatorConfig} config - Translator configuration.\n   * @returns {void}\n   */\n  function initTranslationMode(config) {\n    xlateDebug('[XLATE] Translation mode - starting tag-only pass');\n    try {\n      processedElements = new WeakSet();\n      walk(document.body, {}, true);\n\n      var keySet = {};\n      var all = document.querySelectorAll('*');\n      for (var i = 0; i < all.length; i++) {\n        collectKeysFromElement(all[i], keySet);\n      }\n      var keys = Object.keys(keySet);\n\n      if (!keys.length) {\n        run({});\n        return;\n      }\n\n      var cacheKey = 'xlate:' + config.lang + ':' + config.version + ':keys:' + keys.length;\n      window.__XLATE__.cacheKey = cacheKey;\n\n      var cachedPayload = readCachedBundle(cacheKey);\n      if (cachedPayload) {\n        window.__XLATE__.map = cachedPayload.translations;\n        window.__XLATE__.reviewMap = cachedPayload.reviewed;\n        processedElements = new WeakSet();\n        run(cachedPayload.translations);\n      }\n\n      fetch(config.bundleurl, {\n        method: 'POST',\n        credentials: 'same-origin',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ keys: keys })\n      })\n        .then(function (response) {\n          return response.json();\n        })\n        .then(function (map) {\n          var translations = (map && map.translations) ? map.translations : map;\n          var reviewMap = (map && map.reviewed && typeof map.reviewed === 'object') ? map.reviewed : {};\n          if (!translations || typeof translations !== 'object') {\n            translations = {};\n          }\n          try {\n            localStorage.setItem(cacheKey, JSON.stringify({\n              translations: translations,\n              reviewed: reviewMap\n            }));\n          } catch (e) {\n            // Ignore\n          }\n          window.__XLATE__.map = translations;\n          window.__XLATE__.reviewMap = reviewMap;\n          processedElements = new WeakSet();\n          run(translations);\n          return true;\n        })\n        .catch(function () {\n          run({});\n        });\n    } catch (err) {\n      run({});\n    }\n  }\n\n  /**\n   * @typedef {Object} TranslatorConfig\n   * @property {string} lang Current page language code.\n  * @property {string} sourceLang Base source language for the request (course or site default).\n  * @property {Array<string>} [targetLangs] Target languages configured for this course.\n  * @property {Array<string>} [enabledLangs] Enabled languages available site-wide.\n  * @property {string} [captureSourceLang] Course-specific source language for capture (falls back to sourceLang if not set).\n   * @property {string} bundleurl REST endpoint returning translation bundles.\n   * @property {string} version Bundle version hash used for cache busting.\n   * @property {boolean} isEditing True when Moodle editing mode is active.\n   */\n\n  /**\n   * Initialize translator\n   * @param {TranslatorConfig} config Configuration object injected server-side.\n   */\n  function init(config) {\n    document.documentElement.classList.add('xlate-loading');\n\n    // If editing mode is enabled, skip all capture/tagging logic\n    if (config.isEditing) {\n      xlateDebug('[XLATE] Edit mode detected (isEditing=true): skipping translation/capture logic.');\n      document.documentElement.classList.remove('xlate-loading');\n      return;\n    }\n\n    window.__XLATE__ = createXlateState(config);\n\n    var courseId = resolveCourseId();\n    xlateDebug('[XLATE] Initializing:', {\n      currentLang: config.lang,\n      sourceLang: window.__XLATE__.sourceLang,\n      captureSourceLang: window.__XLATE__.captureSourceLang,\n      targetLangs: window.__XLATE__.targetLangs,\n      isCapture: window.__XLATE__.isCapture,\n      isTargetLang: window.__XLATE__.isTargetLang,\n      courseId: courseId\n    });\n\n    if (window.__XLATE__.isCapture) {\n      initCaptureMode(config, courseId);\n      return;\n    }\n\n    if (!window.__XLATE__.isTargetLang) {\n      xlateDebug('[XLATE] Current language is not a configured target; skipping translation runtime.');\n      document.documentElement.classList.remove('xlate-loading');\n      return;\n    }\n\n    initTranslationMode(config);\n  }\n  Translator.api.init = init;\n\n  Translator.run = run;\n  Translator.init = init;\n\n  return Translator;\n});"],"names":["define","Ajax","ATTRIBUTE_TYPES","detectedStrings","Set","processedElements","WeakSet","lastProcessTime","pendingTranslationKeys","requestedTranslationKeys","missingFetchTimer","indicatorStylesAdded","toggleButton","Translator","xlateDebug","window","XLATE_DEBUG","console","debug","apply","arguments","log","collectContextClasses","element","classList","blacklist","classes","Array","prototype","forEach","call","cls","length","indexOf","test","push","join","collectDataAttributes","attributes","dataAttrs","i","attr","name","value","simpleHash","str","h1","h2","c","charCodeAt","Math","imul","k","s","toString","substring","isTranslatableText","text","match","toLowerCase","hasTranslation","map","key","Object","hasOwnProperty","shouldShowTranslations","__XLATE__","showTranslations","toggleAutoIndicator","show","__xlateIndicator","remove","ensureIndicatorStyles","indicator","document","createElement","className","setAttribute","appendChild","style","textContent","head","updateToggleButtonLabel","enabled","label","innerHTML","handleToggleClick","e","preventDefault","walk","body","ensureToggleControl","isCapture","type","addEventListener","generateKey","parts","parent","parentElement","tagName","parentClasses","parentData","directText","childNodes","node","nodeType","trim","setKeyAttribute","attrType","getKeyFromAttributes","getAttribute","translateElement","dataAttr","hasAttribute","original","getDirectText","storeOriginalValue","restoreOriginalValue","reviewMap","flag","isKeyReviewed","detectComponent","container","closest","region","blockClass","contains","saveToDatabase","existingMap","component","dedupeKey","has","add","pageCourseId","XLATE_COURSEID","M","cfg","courseid","curLang","lang","language","reviewedFlag","sourceLang","captureSourceLang","methodname","args","source","translation","reviewed","context","then","catch","delete","shouldIgnoreElement","XLATE_EXCLUDE_SELECTORS","isArray","sel","matches","currentPath","location","pathname","adminPaths","p","collectKeysFromElement","el","keySet","attrs","j","a","val","processCandidateValue","attrName","tagOnly","setTimeout","size","keys","clear","bundleUrl","fetch","method","credentials","headers","JSON","stringify","response","json","data","translations","markKeysAsRequested","updated","mergeTranslationsIntoMap","reviewChanged","reviewUpdates","incoming","applyReviewUpdates","cacheKey","cachedTranslations","cachedReviewed","cached","localStorage","getItem","cachedPayload","parse","setItem","syncCacheWithLatest","err","unmarkRequestedKeys","fetchMissingTranslations","scheduleMissingFetch","queueMissingTranslation","processElement","sourceText","tag","root","captureSelectors","XLATE_CAPTURE_SELECTORS","roots","found","querySelectorAll","scanRoot","stack","pop","children","run","MutationObserver","muts","mutation","slice","addedNodes","observe","childList","subtree","eventType","now","Date","documentElement","getSourceForElementAttr","typename","dt","dn","initCaptureMode","config","courseId","collected","keyDetails","all","attrname","aval","src","collectKeySetAndDetails","keySetCap","keysCap","bundleurl","sourceMap","associations","toAssociate","ti","detail","associateKeysWithCourse","initTranslationMode","version","payload","readCachedBundle","init","isEditing","resolvedSourceLang","targetLangs","enabledLangs","state","isTargetLang","createXlateState","currentLang","utils","capture","dom","api"],"mappings":"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"}