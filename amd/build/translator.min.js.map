{"version":3,"file":"translator.min.js","sources":["../src/translator.js"],"sourcesContent":["// Local/xlate/amd/src/translator.js\n// Handles DOM translation and automatic key capture with structural-based keys.\n//\n// WORKFLOW:\n// 1. Tag element with data-xlate-key-{type} FIRST (always)\n// 2. If currentLang === siteLang: Save to DB (capture mode)\n// 3. If currentLang !== siteLang: Translate using bundle\ndefine(['core/ajax'], function(Ajax) {\n  var ATTR_KEY_PREFIX = 'data-xlate-key-';\n  var ATTRIBUTE_TYPES = ['placeholder', 'title', 'alt', 'aria-label'];\n\n  var autoDetectEnabled = true;\n  var detectedStrings = new Set();\n  var processedElements = new WeakSet();\n  var lastProcessTime = 0;\n  var processThrottle = 250;\n\n  // ============================================================================\n  // KEY GENERATION - Create structural 12-character hash keys\n  // ============================================================================\n\n  /**\n   * Collect meaningful class names from element\n   * @param {Element} element - The element to collect classes from\n   * @returns {string} Comma-separated class names\n   */\n  function collectContextClasses(element) {\n    if (!element || !element.classList) {\n      return '';\n    }\n\n    var blacklist = ['active', 'show', 'hide', 'hidden', 'collapsed', 'expanded',\n      'd-flex', 'd-none', 'd-block', 'sr-only', 'visually-hidden'];\n\n    var classes = [];\n  Array.prototype.forEach.call(element.classList, function(cls) {\n      if (cls && cls.length > 2 && blacklist.indexOf(cls) === -1 &&\n        !/^[0-9]/.test(cls) && !/^[mp][tblr]?-[0-5]$/.test(cls)) {\n        classes.push(cls);\n      }\n    });\n\n    return classes.join(',');\n  }\n\n  /**\n   * Collect all data-* attributes from element\n   * @param {Element} element - The element to collect attributes from\n   * @returns {string} Comma-separated attribute values\n   */\n  function collectDataAttributes(element) {\n    if (!element || !element.attributes) {\n      return '';\n    }\n\n    var dataAttrs = [];\n    for (var i = 0; i < element.attributes.length; i++) {\n      var attr = element.attributes[i];\n      if (attr.name.indexOf('data-') === 0 && attr.name.indexOf('data-xlate') !== 0 && attr.value) {\n        dataAttrs.push(attr.value);\n      }\n    }\n    return dataAttrs.join(',');\n  }\n\n  /**\n   * Simple deterministic 12-char hash using two 32-bit accumulators (FNV-1a style + mix)\n   * Avoids constant zero padding by combining two hashes and truncating.\n   * @param {string} str - The string to hash\n   * @returns {string} 12-character base36 hash\n   */\n  function simpleHash(str) {\n    // eslint-disable-next-line no-bitwise\n    var h1 = 2166136261 >>> 0; // FNV-1a offset basis\n    // eslint-disable-next-line no-bitwise\n    var h2 = 0x9e3779b1 >>> 0; // Golden ratio constant\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charCodeAt(i);\n      // FNV-1a step on h1\n      // eslint-disable-next-line no-bitwise\n      h1 ^= c;\n      h1 = Math.imul(h1, 16777619);\n\n      // Mix on h2 (inspired by Murmur3 avalanching)\n      h2 = (h2 + c) >>> 0; // eslint-disable-line no-bitwise\n      // eslint-disable-next-line no-bitwise\n      var k = h2 ^ (h2 >>> 16);\n      h2 = Math.imul(k, 2246822507);\n      // eslint-disable-next-line no-bitwise\n      k = h2 ^ (h2 >>> 13);\n      h2 = Math.imul(k, 3266489909);\n      // eslint-disable-next-line no-bitwise\n      h2 = (h2 ^ (h2 >>> 16)) >>> 0;\n    }\n\n    // Combine and encode base36, then truncate to 12 chars\n    // eslint-disable-next-line no-bitwise\n    var s = (h1 >>> 0).toString(36) + (h2 >>> 0).toString(36);\n    if (s.length < 12) {\n      s = (s + 'qwertyuiopasdfghjklz').substring(0, 12);\n    } else if (s.length > 12) {\n      s = s.substring(0, 12);\n    }\n    return s;\n  }\n\n  /**\n   * Generate translation key from element structure + text\n   * @param {Element} element - The element to generate key for\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string} 12-character hash key\n   */\n  function generateKey(element, text, type) {\n    if (!element || !text) {\n      return '';\n    }\n\n    var parts = [];\n\n    // Parent context\n    var parent = element.parentElement;\n    if (parent && parent.tagName) {\n      parts.push(parent.tagName.toLowerCase());\n      var parentClasses = collectContextClasses(parent);\n      if (parentClasses) {\n        parts.push(parentClasses);\n      }\n      var parentData = collectDataAttributes(parent);\n      if (parentData) {\n        parts.push(parentData);\n      }\n    }\n\n    // Current element context\n    if (element.tagName) {\n      parts.push(element.tagName.toLowerCase());\n    }\n    var classes = collectContextClasses(element);\n    if (classes) {\n      parts.push(classes);\n    }\n    var dataAttrs = collectDataAttributes(element);\n    if (dataAttrs) {\n      parts.push(dataAttrs);\n    }\n\n    // Type and text\n    if (type && type !== 'text') {\n      parts.push(type);\n    }\n    parts.push(text);\n\n    return simpleHash(parts.join('.'));\n  }\n\n  // ============================================================================\n  // KEY ATTRIBUTE MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Set data-xlate-key-{type} attribute\n   * @param {Element} element - The element to set attribute on\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The key value\n   */\n  function setKeyAttribute(element, type, key) {\n    if (!element || !key) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    element.setAttribute(ATTR_KEY_PREFIX + attrType, key);\n  }\n\n  /**\n   * Get data-xlate-key-{type} attribute\n   * @param {Element} element - The element to get attribute from\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string|null} The key value\n   */\n  function getKeyFromAttributes(element, type) {\n    if (!element) {\n      return null;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    return element.getAttribute(ATTR_KEY_PREFIX + attrType);\n  }\n\n  // ============================================================================\n  // TRANSLATION (Step 3: currentLang !== siteLang)\n  // ============================================================================\n\n  /**\n   * Translate element using bundle\n   * @param {Element} element - The element to translate\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {Object} map - The translation map\n   */\n  function translateElement(element, type, map) {\n    var key = getKeyFromAttributes(element, type);\n    if (!key || !map[key]) {\n      return;\n    }\n\n    if (type === 'text') {\n      element.textContent = map[key];\n    } else {\n      element.setAttribute(type, map[key]);\n    }\n  }\n\n  // ============================================================================\n  // CAPTURE (Step 2: currentLang === siteLang)\n  // ============================================================================\n\n  /**\n   * Detect component from element context\n   * @param {Element} element - The element to detect component for\n   * @returns {string} Component name\n   */\n  function detectComponent(element) {\n    if (!element) {\n      return 'core';\n    }\n\n    var container = element.closest('[data-region]');\n    if (container) {\n      var region = container.getAttribute('data-region');\n      if (region) {\n        return 'region_' + region;\n      }\n    }\n\n    container = element.closest('.block');\n    if (container) {\n      var blockClass = container.className.match(/block_(\\w+)/);\n      if (blockClass) {\n        return 'block_' + blockClass[1];\n      }\n    }\n\n    if (document.body.classList.contains('path-admin')) {\n      return 'admin';\n    }\n\n    return 'core';\n  }\n\n  /**\n   * Save translatable string to database\n   * @param {Element} element - The element being saved\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The generated key\n   */\n  function saveToDatabase(element, text, type, key) {\n    var component = detectComponent(element);\n    var dedupeKey = component + ':' + key + ':' + type;\n\n    if (detectedStrings.has(dedupeKey)) {\n      return;\n    }\n    detectedStrings.add(dedupeKey);\n\n    Ajax.call([{\n      methodname: 'local_xlate_save_key',\n      args: {\n        component: component,\n        key: key,\n        source: text,\n        lang: (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en',\n        translation: text\n      }\n  }])[0].then(function() {\n      if (window.__XLATE__) {\n        if (!window.__XLATE__.map) {\n          window.__XLATE__.map = {};\n        }\n        window.__XLATE__.map[key] = text;\n      }\n      return true;\n  }).catch(function() {\n      detectedStrings.delete(dedupeKey);\n    });\n  }\n\n  // ============================================================================\n  // ELEMENT PROCESSING (Step 1: Tag FIRST)\n  // ============================================================================\n\n  /**\n   * Check if element should be ignored\n   * @param {Element} element - The element to check\n   * @returns {boolean} True if should be ignored\n   */\n  function shouldIgnoreElement(element) {\n    if (!element || !element.tagName) {\n      return true;\n    }\n\n    var tagName = element.tagName.toLowerCase();\n    if (['script', 'style', 'meta', 'link', 'noscript', 'head'].indexOf(tagName) !== -1) {\n      return true;\n    }\n\n    if (element.hasAttribute('data-xlate-ignore') || element.closest('[data-xlate-ignore]')) {\n      return true;\n    }\n\n    // Do not skip elements just because they already have key attributes;\n    // we rely on processedElements to prevent duplicate work.\n\n    // Admin paths\n    var currentPath = window.location.pathname || '';\n    var adminPaths = ['/admin/', '/local/xlate/', '/course/modedit.php'];\n    for (var p = 0; p < adminPaths.length; p++) {\n      if (currentPath.indexOf(adminPaths[p]) === 0) {\n        return true;\n      }\n    }\n\n    // Admin selectors\n    var adminSelectors = ['.navbar', '.navigation', '.breadcrumb', '.drawer', '.tooltip'];\n    for (var s = 0; s < adminSelectors.length; s++) {\n      if (element.closest(adminSelectors[s])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if text is translatable\n   * @param {string} text - The text to check\n   * @returns {boolean} True if translatable\n   */\n  function isTranslatableText(text) {\n    if (!text || text.length < 3) {\n      return false;\n    }\n\n    var alphaCount = (text.match(/[a-zA-Z]/g) || []).length;\n    if (alphaCount < text.length * 0.3) {\n      return false;\n    }\n\n    var commonWords = ['ok', 'id', 'url', 'api'];\n    if (commonWords.indexOf(text.toLowerCase()) !== -1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Extract clean text from element\n   * @param {Element} element - The element to extract text from\n   * @returns {string} Cleaned text content\n   */\n  function extractCleanText(element) {\n    if (!element) {\n      return '';\n    }\n\n    if (element.children.length === 0) {\n      return element.textContent.trim();\n    }\n\n    var simpleFormatting = true;\n    for (var i = 0; i < element.children.length; i++) {\n      var tag = element.children[i].tagName.toLowerCase();\n      if (['b', 'i', 'em', 'strong', 'span', 'small'].indexOf(tag) === -1) {\n        simpleFormatting = false;\n        break;\n      }\n    }\n\n    return simpleFormatting ? element.textContent.trim() : '';\n  }\n\n  /**\n   * Collect any data-xlate-key-* attribute values from an element into a set-like object\n   * @param {Element} el - Element to inspect\n   * @param {Object} keySet - Object used as a set to store keys\n   */\n  function collectKeysFromElement(el, keySet) {\n    var attrs = el && el.attributes;\n    if (!attrs) {\n      return;\n    }\n    for (var j = 0; j < attrs.length; j++) {\n      var a = attrs[j];\n      var name = a && a.name;\n      if (name && name.indexOf(ATTR_KEY_PREFIX) === 0) {\n        var val = a.value;\n        if (val) {\n          keySet[val] = true;\n        }\n      }\n    }\n  }\n\n  /**\n   * Process single element - TAG, then SAVE or TRANSLATE\n   * @param {Element} element - The element to process\n   * @param {Object} map - The translation map\n   * @param {boolean} tagOnly - When true, only tag keys without saving/translating\n   */\n  function processElement(element, map, tagOnly) {\n    if (shouldIgnoreElement(element) || processedElements.has(element)) {\n      return;\n    }\n  processedElements.add(element);\n\n    var currentLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var siteLang = (window.__XLATE__ && window.__XLATE__.siteLang) || 'en';\n    var isCapture = (currentLang === siteLang) && autoDetectEnabled;\n\n    // Process text content\n    var textContent = extractCleanText(element);\n    if (textContent && isTranslatableText(textContent)) {\n      var textKey = generateKey(element, textContent, 'text');\n      if (textKey) {\n        setKeyAttribute(element, 'text', textKey); // Step 1: TAG\n        if (!tagOnly) {\n          if (isCapture) {\n            saveToDatabase(element, textContent, 'text', textKey); // Step 2: SAVE\n          } else if (map) {\n            translateElement(element, 'text', map); // Step 3: TRANSLATE\n          }\n        }\n      }\n    }\n\n    // Process attributes\n  ATTRIBUTE_TYPES.forEach(function(attr) {\n      if (!element.hasAttribute(attr)) {\n        return;\n      }\n      var value = element.getAttribute(attr).trim();\n      if (value && isTranslatableText(value)) {\n        var attrKey = generateKey(element, value, attr);\n        if (attrKey) {\n          setKeyAttribute(element, attr, attrKey); // Step 1: TAG\n          if (!tagOnly) {\n            if (isCapture) {\n              saveToDatabase(element, value, attr, attrKey); // Step 2: SAVE\n            } else if (map) {\n              translateElement(element, attr, map); // Step 3: TRANSLATE\n            }\n          }\n        }\n      }\n    });\n  }\n\n  // ============================================================================\n  // DOM WALKING\n  // ============================================================================\n\n  /**\n   * Walk DOM and process elements\n   * @param {Element} root - Root element to start from\n   * @param {Object} map - The translation map\n   * @param {boolean} tagOnly - When true, only tag keys without saving/translating\n   */\n  function walk(root, map, tagOnly) {\n    if (!root) {\n      return;\n    }\n\n    var stack = [root];\n    while (stack.length) {\n      var el = stack.pop();\n      if (el.nodeType === 1) {\n        if (el.hasAttribute && !el.hasAttribute('data-xlate-ignore')) {\n          processElement(el, map, tagOnly);\n        }\n\n        var children = el.children || [];\n        for (var i = 0; i < children.length; i++) {\n          stack.push(children[i]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Run translator\n   * @param {Object} map - The translation map\n   */\n  function run(map) {\n    try {\n  walk(document.body, map || {});\n\n      if (autoDetectEnabled) {\n  setTimeout(function() {\n          walk(document.body, map || {});\n        }, 1000);\n      }\n\n  var mo = new MutationObserver(function(muts) {\n  muts.forEach(function(mutation) {\n          Array.prototype.slice.call(mutation.addedNodes || []).forEach(function(node) {\n            if (node.nodeType === 1) {\n              walk(node, map || {});\n            }\n          });\n        });\n      });\n  mo.observe(document.body, {childList: true, subtree: true});\n\n      if (typeof window.addEventListener === 'function') {\n        ['focus', 'click', 'scroll'].forEach(function(eventType) {\n          document.addEventListener(eventType, function() {\n            var now = Date.now();\n            if (now - lastProcessTime > processThrottle) {\n              lastProcessTime = now;\n              setTimeout(function() {\n                walk(document.body, map || {});\n              }, 100);\n            }\n          }, true);\n        });\n      }\n    } finally {\n      document.documentElement.classList.remove('xlate-loading');\n    }\n  }\n\n  /**\n   * Initialize translator\n   * @param {Object} config - Configuration object\n   */\n  function init(config) {\n    document.documentElement.classList.add('xlate-loading');\n\n    if (typeof config.autodetect !== 'undefined') {\n      autoDetectEnabled = !(config.autodetect === false || config.autodetect === 'false');\n    }\n\n    window.__XLATE__ = {\n      lang: config.lang,\n      siteLang: config.siteLang,\n      map: {},\n      sourceMap: {}\n    };\n\n    /**\n     * Process bundle data\n     * @param {Object} bundleData - The bundle data\n     */\n    var currentLang = config.lang;\n    var siteLang = config.siteLang;\n    var isCapture = (currentLang === siteLang) && autoDetectEnabled;\n\n    // In capture mode: tag + save immediately, but optionally fetch bundle for spot checking\n    if (isCapture) {\n      processedElements = new WeakSet();\n      // Normal run will tag and save\n      walk(document.body, {}, false);\n      run({});\n\n      if (config.loadBundleOnSiteLang) {\n        try {\n          // Collect tagged keys from DOM\n          var keySetCap = {};\n          var allCap = document.querySelectorAll('*');\n          for (var ci = 0; ci < allCap.length; ci++) {\n            collectKeysFromElement(allCap[ci], keySetCap);\n          }\n          var keysCap = Object.keys(keySetCap);\n          if (keysCap.length) {\n            fetch(config.bundleurl, {\n              method: 'POST',\n              credentials: 'same-origin',\n              headers: {'Content-Type': 'application/json'},\n              body: JSON.stringify({keys: keysCap})\n            })\n            .then(function(response) {\n              return response.json();\n            })\n            .then(function(map) {\n              var translations = (map && map.translations) ? map.translations : map;\n              if (!translations || typeof translations !== 'object') {\n                translations = {};\n              }\n              window.__XLATE__.map = translations; // For console spot-checking\n              return true;\n            })\n            .catch(function() { /* Ignore */ });\n          }\n        } catch (spotErr) {\n          // Ignore\n        }\n      }\n      return;\n    }\n\n    // Translation mode: pre-tag, collect keys, request filtered bundle, then translate\n    try {\n      // Pre-tag only\n      processedElements = new WeakSet();\n      walk(document.body, {}, true);\n\n      // Collect tagged keys from DOM\n      var keySet = {};\n      var all = document.querySelectorAll('*');\n      for (var i = 0; i < all.length; i++) {\n        collectKeysFromElement(all[i], keySet);\n      }\n      var keys = Object.keys(keySet);\n\n      // Short-circuit if no keys\n      if (keys.length === 0) {\n        run({});\n        return;\n      }\n\n      var k = 'xlate:' + config.lang + ':' + config.version + ':keys:' + keys.length;\n      var cached = null;\n      try {\n        cached = localStorage.getItem(k);\n      } catch (e) {\n        // Ignore\n      }\n      if (cached) {\n        try {\n          var cachedMap = JSON.parse(cached);\n          if (cachedMap && typeof cachedMap === 'object') {\n            window.__XLATE__.map = cachedMap;\n            processedElements = new WeakSet();\n            run(cachedMap);\n          }\n        } catch (e) {\n          // Ignore\n        }\n      }\n\n      fetch(config.bundleurl, {\n        method: 'POST',\n        credentials: 'same-origin',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({keys: keys})\n      })\n      .then(function(response) {\n        return response.json();\n      })\n      .then(function(map) {\n        // Accept either flat map or legacy wrapper\n        var translations = (map && map.translations) ? map.translations : map;\n        if (!translations || typeof translations !== 'object') {\n          translations = {};\n        }\n        try {\n          localStorage.setItem(k, JSON.stringify(translations));\n        } catch (e) {\n          // Ignore\n        }\n        window.__XLATE__.map = translations;\n        processedElements = new WeakSet();\n        run(translations);\n        return true;\n      })\n      .catch(function() {\n        run({});\n      });\n    } catch (err) {\n      run({});\n    }\n  }\n\n  /**\n   * Enable or disable auto-detect\n   * @param {boolean} enabled - Whether to enable auto-detect\n   */\n  function setAutoDetect(enabled) {\n    autoDetectEnabled = !!enabled;\n  }\n\n  return {\n    run: run,\n    init: init,\n    setAutoDetect: setAutoDetect\n  };\n});\n"],"names":["define","Ajax","ATTRIBUTE_TYPES","autoDetectEnabled","detectedStrings","Set","processedElements","WeakSet","lastProcessTime","collectContextClasses","element","classList","blacklist","classes","Array","prototype","forEach","call","cls","length","indexOf","test","push","join","collectDataAttributes","attributes","dataAttrs","i","attr","name","value","generateKey","text","type","parts","parent","parentElement","tagName","toLowerCase","parentClasses","parentData","str","h1","h2","c","charCodeAt","Math","imul","k","s","toString","substring","simpleHash","setKeyAttribute","key","attrType","setAttribute","translateElement","map","getAttribute","getKeyFromAttributes","textContent","saveToDatabase","component","container","closest","region","blockClass","className","match","document","body","contains","detectComponent","dedupeKey","has","add","methodname","args","source","lang","window","__XLATE__","M","cfg","language","translation","then","catch","delete","isTranslatableText","collectKeysFromElement","el","keySet","attrs","j","a","val","processElement","tagOnly","hasAttribute","currentPath","location","pathname","adminPaths","p","adminSelectors","shouldIgnoreElement","isCapture","siteLang","children","trim","simpleFormatting","tag","extractCleanText","textKey","attrKey","walk","root","stack","pop","nodeType","run","setTimeout","MutationObserver","muts","mutation","slice","addedNodes","node","observe","childList","subtree","addEventListener","eventType","now","Date","documentElement","remove","init","config","autodetect","sourceMap","loadBundleOnSiteLang","keySetCap","allCap","querySelectorAll","ci","keysCap","Object","keys","fetch","bundleurl","method","credentials","headers","JSON","stringify","response","json","translations","spotErr","all","version","cached","localStorage","getItem","e","cachedMap","parse","setItem","err","setAutoDetect","enabled"],"mappings":"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"}