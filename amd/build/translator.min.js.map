{"version":3,"file":"translator.min.js","sources":["../src/translator.js"],"sourcesContent":["// Local/xlate/amd/src/translator.js\n// Handles DOM translation and automatic key capture with structural-based keys.\n//\n// WORKFLOW:\n// 1. Tag element with data-xlate-key-{type} FIRST (always)\n// 2. If currentLang === sourceLang: Save to DB (capture mode)\n// 3. If currentLang !== sourceLang: Translate using bundle\n/**\n * AMD module that detects, captures, and renders Local Xlate translations.\n *\n * Responsibilities:\n *  - Capture mode: tag DOM nodes, check existing bundle entries, persist newly\n *    discovered strings, and link keys to the active course when permitted.\n *  - Translation mode: tag DOM nodes, request a filtered bundle, apply\n *    translations, and track subsequent DOM mutations to keep content synced.\n */\ndefine(['core/ajax'], function (Ajax) {\n  var ATTR_KEY_PREFIX = 'data-xlate-key-';\n  var ATTRIBUTE_TYPES = [\n    'placeholder', 'title', 'alt', 'aria-label'\n  ];\n  var KEYED_ATTRIBUTE_TYPES = ['content'].concat(ATTRIBUTE_TYPES);\n\n  // Auto-detection is always enabled; keys are always auto-assigned.\n  var detectedStrings = new Set();\n  var processedElements = new WeakSet();\n  var lastProcessTime = 0;\n  var processThrottle = 250;\n  var pendingTranslationKeys = new Set();\n  var requestedTranslationKeys = new Set();\n  var missingFetchTimer = null;\n  var indicatorStylesAdded = false;\n  var BLOCK_CHILD_TAGS = [\n    'div', 'section', 'article', 'header', 'footer', 'main', 'aside', 'nav',\n    'figure', 'figcaption', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol',\n    'li', 'p'\n  ];\n  var BLOCK_CHILD_SELECTOR = BLOCK_CHILD_TAGS.join(', ');\n  if (typeof window !== 'undefined') {\n    if (typeof window.XLATE_LAST_TOGGLE_REQUEST === 'undefined') {\n      window.XLATE_LAST_TOGGLE_REQUEST = null;\n    }\n    if (typeof window.XLATE_LAST_TOGGLE_APPLIED === 'undefined') {\n      window.XLATE_LAST_TOGGLE_APPLIED = null;\n    }\n  }\n  var ALLOWED_INLINE_TAGS = {\n    'a': ['href', 'title', 'target', 'rel'],\n    'abbr': ['title'],\n    'b': [],\n    'br': [],\n    'cite': [],\n    'code': [],\n    'em': [],\n    'i': [],\n    'kbd': [],\n    'mark': [],\n    'q': [],\n    's': [],\n    'small': [],\n    'span': ['class'],\n    'strong': [],\n    'sub': [],\n    'sup': [],\n    'u': []\n  };\n  var INLINE_PIGGYBACK_TAGS = ['strong', 'b', 'em', 'i', 'u', 'mark'];\n  /* Translator namespace to expose public API while keeping internal helpers private. */\n  var Translator = {};\n  Translator.utils = {};\n  Translator.keys = {};\n  Translator.attrs = {};\n  Translator.capture = {};\n  Translator.dom = {};\n  Translator.api = {};\n\n  /**\n   * Persist metadata about the most recent toggle request for debugging.\n   * @param {{visible?: boolean}|null} request - Requested visibility payload.\n   * @param {string} source - Identifier describing who triggered the request.\n   * @returns {void}\n   */\n  function recordToggleRequest(request, source) {\n    if (typeof window === 'undefined') {\n      return;\n    }\n    window.XLATE_LAST_TOGGLE_REQUEST = {\n      time: Date.now(),\n      request: request || {},\n      source: source || 'direct'\n    };\n  }\n\n  /**\n   * Determine if a URL value is safe for href/src attributes.\n   * @param {string} url - Candidate URL.\n   * @returns {boolean} True when URL uses an allowed scheme.\n   */\n  function isSafeUrl(url) {\n    if (!url) {\n      return false;\n    }\n    var trimmed = url.trim();\n    if (!trimmed) {\n      return false;\n    }\n    if (trimmed[0] === '#') {\n      return true;\n    }\n    var lower = trimmed.toLowerCase();\n    var unsafePattern = /^(?:\\s*(?:javascript|data)\\s*:)/;\n    if (unsafePattern.test(lower)) {\n      return false;\n    }\n    var allowedPattern = /^(https?:|mailto:|tel:)/;\n    return allowedPattern.test(lower);\n  }\n\n  /**\n   * Remove a node while keeping its children in place.\n   * @param {Element} element - Node to unwrap.\n   * @returns {void}\n   */\n  function unwrapElement(element) {\n    if (!element || !element.parentNode) {\n      return;\n    }\n    var parent = element.parentNode;\n    while (element.firstChild) {\n      parent.insertBefore(element.firstChild, element);\n    }\n    parent.removeChild(element);\n  }\n\n  /**\n   * Sanitize attributes on an element to the allowed list for that tag.\n   * @param {Element} element - Target element.\n   * @param {Array<string>} allowedAttrs - Whitelisted attribute names.\n   * @returns {void}\n   */\n  function sanitizeAttributes(element, allowedAttrs) {\n    if (!element || !element.attributes) {\n      return;\n    }\n    var attrs = Array.prototype.slice.call(element.attributes);\n    attrs.forEach(function (attr) {\n      var name = attr.name.toLowerCase();\n      if (allowedAttrs.indexOf(name) === -1) {\n        element.removeAttribute(attr.name);\n        return;\n      }\n      if ((name === 'href' || name === 'src') && !isSafeUrl(attr.value || '')) {\n        element.removeAttribute(attr.name);\n        return;\n      }\n      if (name === 'target' && attr.value !== '_blank') {\n        element.removeAttribute(attr.name);\n        return;\n      }\n      if (name === 'target' && attr.value === '_blank') {\n        element.setAttribute('rel', 'noopener noreferrer');\n      }\n    });\n  }\n\n  /**\n   * Recursively sanitize HTML nodes to a safe inline subset.\n   * @param {Node} root - Root node to sanitize.\n   * @returns {void}\n   */\n  function sanitizeNode(root) {\n    if (!root || !root.childNodes) {\n      return;\n    }\n    var children = Array.prototype.slice.call(root.childNodes);\n    children.forEach(function (child) {\n      if (child.nodeType === 1) {\n        var tag = child.tagName.toLowerCase();\n        if (!Object.prototype.hasOwnProperty.call(ALLOWED_INLINE_TAGS, tag)) {\n          sanitizeNode(child);\n          unwrapElement(child);\n          return;\n        }\n        sanitizeAttributes(child, ALLOWED_INLINE_TAGS[tag]);\n        sanitizeNode(child);\n        return;\n      }\n      if (child.nodeType !== 3) {\n        child.parentNode.removeChild(child);\n      }\n    });\n  }\n\n  /**\n   * Sanitize translated HTML before injecting into the DOM.\n   * @param {string} value - Raw translation string.\n   * @param {string} targetTag - Tag name of the host element.\n   * @returns {string} Sanitized HTML safe for innerHTML.\n   */\n  function sanitizeTranslationHtml(value, targetTag) {\n    if (!value) {\n      return '';\n    }\n    var container = document.createElement('div');\n    container.innerHTML = value;\n    sanitizeNode(container);\n\n    // When translators wrap the same tag (e.g. <p> inside <p>), unwrap it.\n    if (targetTag && container.childNodes.length === 1) {\n      var firstChild = container.childNodes[0];\n      if (firstChild.nodeType === 1 && firstChild.tagName.toLowerCase() === targetTag && firstChild.childNodes.length) {\n        var unwrap = document.createElement('div');\n        while (firstChild.firstChild) {\n          unwrap.appendChild(firstChild.firstChild);\n        }\n        return unwrap.innerHTML;\n      }\n    }\n\n    return container.innerHTML;\n  }\n\n  /**\n   * Obtain direct child text content (excluding descendants) from an element.\n   * @param {Element} element - Target element.\n   * @returns {string} Direct text content.\n   */\n  function getDirectChildText(element) {\n    if (!element || !element.childNodes) {\n      return '';\n    }\n    var text = '';\n    for (var i = 0; i < element.childNodes.length; i++) {\n      var node = element.childNodes[i];\n      if (node.nodeType === 3) { // TEXT_NODE\n        text += node.textContent;\n      }\n    }\n    return text.trim();\n  }\n\n  /**\n   * Extract a plain-text version of an HTML string by stripping tags.\n   * @param {string} value - String potentially containing markup.\n   * @returns {string} Plain text content.\n   */\n  function extractPlainText(value) {\n    if (!value) {\n      return '';\n    }\n    if (value.indexOf('<') === -1) {\n      return value.trim();\n    }\n    var container = document.createElement('div');\n    container.innerHTML = value;\n    return (container.textContent || container.innerText || '').trim();\n  }\n\n  /**\n   * Determine the capture payload for an element, preserving safe inline markup.\n   * @param {Element} element - Source element.\n   * @returns {string} Sanitized innerHTML when markup exists, otherwise text.\n   */\n  function getElementSourcePayload(element) {\n    if (!element) {\n      return '';\n    }\n    var raw = element.innerHTML || '';\n    var tag = element.tagName ? element.tagName.toLowerCase() : '';\n    if (raw && raw.indexOf('<') !== -1) {\n      var sanitized = sanitizeTranslationHtml(raw, tag).trim();\n      if (sanitized) {\n        return sanitized;\n      }\n      if (window.__XLATE__ && window.__XLATE__.isCapture) {\n        xlateDebug(\n          '[XLATE][Capture] Sanitized HTML empty for',\n          describeElementContext(element),\n          'raw snippet:',\n          abbreviateValue(raw)\n        );\n      }\n      var fallbackPlain = extractPlainText(raw);\n      if (fallbackPlain) {\n        return fallbackPlain;\n      }\n    }\n    var direct = getDirectChildText(element);\n    if (direct) {\n      return direct;\n    }\n    var textContent = (element.textContent || '').trim();\n    return textContent;\n  }\n\n  /**\n   * Wrapper for debug logging which only emits when server-side debug is enabled.\n   * The hook in PHP will expose `window.XLATE_DEBUG` as true when Moodle debugging\n   * is set to DEVELOPER. This keeps noisy logs out of production.\n   */\n  /* eslint-disable no-console */\n  /**\n   * Debug logging helper. Emits messages only when `window.XLATE_DEBUG` is truthy.\n   * @returns {void}\n   */\n  function xlateDebug() {\n    if (typeof window !== 'undefined' && window.XLATE_DEBUG) {\n      if (typeof console !== 'undefined' && typeof console.debug === 'function') {\n        console.debug.apply(console, arguments);\n      } else if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  }\n\n  /* eslint-enable no-console */\n\n  /**\n   * Return a short descriptor for logging the element context.\n   * @param {Element} element - Element to summarise.\n   * @returns {string} Summary string including tag/id/class hints.\n   */\n  function describeElementContext(element) {\n    if (!element || !element.tagName) {\n      return '<unknown>';\n    }\n    var tag = element.tagName.toLowerCase();\n    var id = element.id ? '#' + element.id : '';\n    var classSuffix = '';\n    if (element.className && typeof element.className === 'string') {\n      var classes = element.className.trim().split(/\\s+/).filter(Boolean).slice(0, 3);\n      if (classes.length) {\n        classSuffix = '.' + classes.join('.');\n      }\n    }\n    return tag + id + classSuffix;\n  }\n\n  /**\n   * Produce a short snippet of a string for debug logging.\n   * @param {string} value - Original string.\n   * @returns {string} Abbreviated string capped to ~80 chars.\n   */\n  function abbreviateValue(value) {\n    if (!value) {\n      return '';\n    }\n    var trimmed = value.trim();\n    if (trimmed.length <= 80) {\n      return trimmed;\n    }\n    return trimmed.substring(0, 77) + '...';\n  }\n\n  // ============================================================================\n  // KEY GENERATION - Create structural 12-character hash keys\n  // ============================================================================\n\n  /**\n   * Collect relevant CSS classes to contribute to structural hash context.\n   * @param {Element} element - Element whose classes will be analyzed.\n   * @returns {string} Comma-separated class list used for hashing.\n   */\n  function collectContextClasses(element) {\n    if (!element || !element.classList) {\n      return '';\n    }\n\n    var blacklist = [\n      'active', 'show', 'hide', 'hidden', 'collapsed', 'expanded',\n      'd-flex', 'd-none', 'd-block', 'sr-only', 'visually-hidden'\n    ];\n    var classes = [];\n    Array.prototype.forEach.call(element.classList, function (cls) {\n      if (cls && cls.length > 2 && blacklist.indexOf(cls) === -1 &&\n        !/^[0-9]/.test(cls) && !/^[mp][tblr]?-[0-5]$/.test(cls)) {\n        classes.push(cls);\n      }\n    });\n\n    return classes.join(',');\n  }\n\n  /**\n   * Collect all non-XLATE data-* attribute values for hashing context.\n   * @param {Element} element - Element to inspect.\n   * @returns {string} Comma-separated attribute values.\n   */\n  function collectDataAttributes(element) {\n    if (!element || !element.attributes) {\n      return '';\n    }\n\n    var dataAttrs = [];\n    for (var i = 0; i < element.attributes.length; i++) {\n      var attr = element.attributes[i];\n      if (attr.name.indexOf('data-') === 0 && attr.name.indexOf('data-xlate') !== 0 && attr.value) {\n        dataAttrs.push(attr.value);\n      }\n    }\n    return dataAttrs.join(',');\n  }\n  Translator.utils.collectContextClasses = collectContextClasses;\n  Translator.utils.collectDataAttributes = collectDataAttributes;\n\n  /**\n   * Simple deterministic 12-char hash using two 32-bit accumulators (FNV-1a style + mix)\n   * Avoids constant zero padding by combining two hashes and truncating.\n   * @param {string} str - The string to hash\n   * @returns {string} 12-character base36 hash\n   */\n  function simpleHash(str) {\n    // eslint-disable-next-line no-bitwise\n    var h1 = 2166136261 >>> 0; // FNV-1a offset basis\n    // eslint-disable-next-line no-bitwise\n    var h2 = 0x9e3779b1 >>> 0; // Golden ratio constant\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charCodeAt(i);\n      // FNV-1a step on h1\n      // eslint-disable-next-line no-bitwise\n      h1 ^= c;\n      h1 = Math.imul(h1, 16777619);\n\n      // Mix on h2 (inspired by Murmur3 avalanching)\n      h2 = (h2 + c) >>> 0; // eslint-disable-line no-bitwise\n      // eslint-disable-next-line no-bitwise\n      var k = h2 ^ (h2 >>> 16);\n      h2 = Math.imul(k, 2246822507);\n      // eslint-disable-next-line no-bitwise\n      k = h2 ^ (h2 >>> 13);\n      h2 = Math.imul(k, 3266489909);\n      // eslint-disable-next-line no-bitwise\n      h2 = (h2 ^ (h2 >>> 16)) >>> 0;\n    }\n\n    // Combine and encode base36, then truncate to 12 chars\n    // eslint-disable-next-line no-bitwise\n    var s = (h1 >>> 0).toString(36) + (h2 >>> 0).toString(36);\n    if (s.length < 12) {\n      s = (s + 'qwertyuiopasdfghjklz').substring(0, 12);\n    } else if (s.length > 12) {\n      s = s.substring(0, 12);\n    }\n    return s;\n  }\n  /**\n   * Determine whether text should be considered for translation.\n   * @param {string} text - Candidate text\n   * @returns {boolean} True when text looks translatable\n   */\n  function isTranslatableText(text) {\n    if (!text || text.length < 3) {\n      return false;\n    }\n\n    var alphaCount = (text.match(/[a-zA-Z]/g) || []).length;\n    if (alphaCount < text.length * 0.3) {\n      return false;\n    }\n\n    var commonWords = ['ok', 'id', 'url', 'api'];\n    if (commonWords.indexOf(text.toLowerCase()) !== -1) {\n      return false;\n    }\n\n    return true;\n  }\n  Translator.utils.isTranslatableText = isTranslatableText;\n  Translator.utils.simpleHash = simpleHash;\n\n  /**\n   * Determine whether a translation map already contains a key.\n   * @param {Object<string,string>} map - Translation lookup table.\n   * @param {string} key - Structural key to check.\n   * @returns {boolean} True when the key exists in the map.\n   */\n  function hasTranslation(map, key) {\n    return !!(map && Object.prototype.hasOwnProperty.call(map, key));\n  }\n  Translator.utils.hasTranslation = hasTranslation;\n\n  /**\n   * Persist the original value for an element so toggles can restore it later.\n   * @param {Element} element - Element being translated.\n   * @param {string} type - Translation type (`text` or attribute name).\n   * @returns {void}\n   */\n  function storeOriginalValue(element, type) {\n    if (!element) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    var dataAttr = 'data-xlate-original-' + attrType;\n    if (element.hasAttribute(dataAttr)) {\n      return;\n    }\n    var original = '';\n    if (type === 'text') {\n      original = element.innerHTML;\n    } else {\n      original = element.getAttribute(type) || '';\n    }\n    element.setAttribute(dataAttr, original);\n  }\n\n  /**\n   * Restore the previously stored original value for an element.\n   * @param {Element} element - Element to restore.\n   * @param {string} type - Translation type (`text` or attribute name).\n   * @returns {void}\n   */\n  function restoreOriginalValue(element, type) {\n    if (!element) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    var dataAttr = 'data-xlate-original-' + attrType;\n    if (!element.hasAttribute(dataAttr)) {\n      return;\n    }\n    var original = element.getAttribute(dataAttr) || '';\n    if (type === 'text') {\n      element.innerHTML = original;\n    } else {\n      element.setAttribute(type, original);\n    }\n  }\n\n  /**\n   * Determine whether translations should currently be displayed.\n   * @returns {boolean} True when translation overlay is enabled.\n   */\n  function shouldShowTranslations() {\n    if (!window.__XLATE__) {\n      return true;\n    }\n    return window.__XLATE__.showTranslations !== false;\n  }\n\n  /**\n   * Retrieve the captured source string for a translation key when available.\n   * @param {string} key - Structural key identifier.\n   * @returns {string|null} Original source string or null when unavailable.\n   */\n  function getSourceStringForKey(key) {\n    if (!key || !window.__XLATE__ || !window.__XLATE__.sourceStrings) {\n      return null;\n    }\n    if (Object.prototype.hasOwnProperty.call(window.__XLATE__.sourceStrings, key)) {\n      return window.__XLATE__.sourceStrings[key];\n    }\n    return null;\n  }\n\n  /**\n   * Dispatch a custom event for other modules (e.g., UI controls).\n   * @param {string} name - Event name to dispatch.\n   * @param {Object} detail - Optional detail payload.\n   * @returns {void}\n   */\n  function dispatchXlateEvent(name, detail) {\n    if (typeof document === 'undefined' || typeof document.dispatchEvent !== 'function') {\n      return;\n    }\n    var payload = detail || {};\n    var event;\n    try {\n      event = new CustomEvent(name, { detail: payload });\n    } catch (err) {\n      event = document.createEvent('CustomEvent');\n      event.initCustomEvent(name, true, true, payload);\n    }\n    document.dispatchEvent(event);\n  }\n\n  /**\n   * Ensure source-language strings are available for the provided keys.\n   * @param {Array<string>} keys - Translation keys to ensure.\n   * @returns {Promise<void>} Resolves once source strings are hydrated.\n   */\n  function ensureSourceStrings(keys) {\n    if (!window.__XLATE__) {\n      return Promise.resolve();\n    }\n    var store = window.__XLATE__.sourceStrings || {};\n    window.__XLATE__.sourceStrings = store;\n    var missing = [];\n    if (Array.isArray(keys)) {\n      keys.forEach(function (key) {\n        if (!key) {\n          return;\n        }\n        if (!Object.prototype.hasOwnProperty.call(store, key) || store[key] === '') {\n          missing.push(key);\n        }\n      });\n    }\n    if (!missing.length) {\n      return Promise.resolve();\n    }\n    if (window.__XLATE__.sourceFetchPromise) {\n      return window.__XLATE__.sourceFetchPromise;\n    }\n\n    var bundleUrl = window.__XLATE__.bundleUrl || window.__XLATE__.bundleurl || '';\n    if (!bundleUrl) {\n      return Promise.resolve();\n    }\n\n    var sourceUrl;\n    try {\n      sourceUrl = new URL(bundleUrl, window.location.origin);\n    } catch (err) {\n      var anchor = document.createElement('a');\n      anchor.href = bundleUrl;\n      sourceUrl = new URL(anchor.href, window.location.origin);\n    }\n\n    var sourceLang = window.__XLATE__.captureSourceLang || window.__XLATE__.sourceLang || window.__XLATE__.lang;\n    if (!sourceLang) {\n      return Promise.resolve();\n    }\n    sourceUrl.searchParams.set('lang', sourceLang);\n\n    var payload = { keys: missing };\n    window.__XLATE__.sourceFetchPromise = fetch(sourceUrl.toString(), {\n      method: 'POST',\n      credentials: 'same-origin',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload)\n    })\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (map) {\n        var providedSources = (map && map.sources && typeof map.sources === 'object') ? map.sources : {};\n        var translations = (map && map.translations && typeof map.translations === 'object') ? map.translations : {};\n        Object.keys(providedSources).forEach(function (key) {\n          store[key] = providedSources[key];\n        });\n        Object.keys(translations).forEach(function (key) {\n          if (!store[key]) {\n            store[key] = translations[key];\n          }\n        });\n      })\n      .catch(function (err) {\n        xlateDebug('[XLATE] Source fetch failed', err);\n      })\n      .finally(function () {\n        window.__XLATE__.sourceFetchPromise = null;\n      });\n\n    return window.__XLATE__.sourceFetchPromise;\n  }\n\n  /**\n   * Apply the desired translation visibility state across the page.\n   * @param {boolean} newValue - True to show translations, false for originals.\n   * @returns {void}\n   */\n  function applyVisibilityState(newValue) {\n    window.__XLATE__.showTranslations = newValue;\n    if (typeof document !== 'undefined' && document.documentElement) {\n      document.documentElement.classList.toggle('xlate-original-visible', !newValue);\n    }\n    processedElements = new WeakSet();\n    refreshVisibleElements(window.__XLATE__.map || {});\n    dispatchXlateEvent('xlate:visibilitychange', { visible: newValue });\n  }\n\n  /**\n   * Toggle the translation visibility and reprocess the DOM.\n   * @param {boolean} [visible] - Optional target visibility (defaults to toggle).\n   * @returns {void}\n   */\n  function setTranslationVisibility(visible) {\n    var requestedVisibility = (typeof visible === 'boolean') ? visible : null;\n    recordToggleRequest({ visible: requestedVisibility }, 'direct_call');\n    if (typeof window !== 'undefined') {\n      window.XLATE_TOGGLE_LOG = window.XLATE_TOGGLE_LOG || [];\n      window.XLATE_TOGGLE_LOG.push({\n        at: Date.now(),\n        requested: requestedVisibility,\n        priorState: shouldShowTranslations()\n      });\n    }\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n    var newValue = (typeof visible === 'boolean') ? visible : !shouldShowTranslations();\n    if (typeof window !== 'undefined') {\n      window.XLATE_LAST_TOGGLE_APPLIED = window.XLATE_LAST_TOGGLE_APPLIED || {};\n      window.XLATE_LAST_TOGGLE_APPLIED.result = newValue;\n    }\n    if (!newValue) {\n      var keys = Object.keys(window.__XLATE__.map || {});\n      ensureSourceStrings(keys).then(function () {\n        applyVisibilityState(newValue);\n      }).catch(function () {\n        applyVisibilityState(newValue);\n      });\n      return;\n    }\n    applyVisibilityState(newValue);\n  }\n\n  /**\n   * Check if a translation key has been human-reviewed.\n   * @param {string} key - Structural translation key.\n   * @returns {boolean} True when the key is marked reviewed.\n   */\n  function isKeyReviewed(key) {\n    if (!window.__XLATE__ || !window.__XLATE__.reviewMap) {\n      return true;\n    }\n    var flag = window.__XLATE__.reviewMap[key];\n    return flag === 1 || flag === '1' || flag === true;\n  }\n\n  /**\n   * Toggle the inline auto-translation indicator for a given element.\n   * @param {Element} element - Host element for the indicator.\n   * @param {string} key - Translation key (used for state tracking).\n   * @param {boolean} show - Whether to display the indicator.\n   * @returns {void}\n   */\n  function toggleAutoIndicator(element, key, show) {\n    if (!element || typeof element !== 'object') {\n      return;\n    }\n    var indicatorsAllowed = !!(window.__XLATE__ && window.__XLATE__.inlineIndicator);\n    if (!indicatorsAllowed || !show) {\n      if (element.__xlateIndicator && element.__xlateIndicator.remove) {\n        element.__xlateIndicator.remove();\n      }\n      element.__xlateIndicator = null;\n      return;\n    }\n\n    if (element.__xlateIndicator) {\n      return;\n    }\n\n    ensureIndicatorStyles();\n\n    var indicator = document.createElement('span');\n    indicator.className = 'xlate-auto-indicator icon fa fa-globe text-muted';\n    indicator.setAttribute('role', 'img');\n    indicator.setAttribute('aria-label', 'AI translated');\n    indicator.setAttribute('title', 'AI translated');\n    indicator.setAttribute('data-xlate-indicator', key || '');\n\n    if (typeof element.appendChild === 'function') {\n      element.appendChild(indicator);\n    }\n\n    element.__xlateIndicator = indicator;\n  }\n\n  /**\n   * Inject the inline styles required for indicators and toggle control.\n   * @returns {void}\n   */\n  function ensureIndicatorStyles() {\n    if (indicatorStylesAdded) {\n      return;\n    }\n    indicatorStylesAdded = true;\n    var style = document.createElement('style');\n    style.setAttribute('data-xlate-style', 'indicator');\n    style.textContent = '' +\n      '.xlate-auto-indicator {' +\n      '  display:inline-flex;' +\n      '  align-items:center;' +\n      '  font-size:0.75em;' +\n      '  margin-left:0.35em;' +\n      '  opacity:0.75;' +\n      '}';\n    document.head.appendChild(style);\n  }\n\n  /**\n   * Generate translation key from element structure + direct text (ignoring children)\n   * @param {Element} element - The element to generate key for\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string} 12-character hash key\n   */\n  function generateKey(element, text, type) {\n    if (!element || !text) {\n      return '';\n    }\n\n    var parts = [];\n\n    // Parent context\n    var parent = element.parentElement;\n    if (parent && parent.tagName) {\n      parts.push(parent.tagName.toLowerCase());\n      var parentClasses = collectContextClasses(parent);\n      if (parentClasses) {\n        parts.push(parentClasses);\n      }\n      var parentData = collectDataAttributes(parent);\n      if (parentData) {\n        parts.push(parentData);\n      }\n    }\n\n    // Current element context\n    if (element.tagName) {\n      parts.push(element.tagName.toLowerCase());\n    }\n    var classes = collectContextClasses(element);\n    if (classes) {\n      parts.push(classes);\n    }\n    var dataAttrs = collectDataAttributes(element);\n    if (dataAttrs) {\n      parts.push(dataAttrs);\n    }\n\n    // Type and direct text only (ignore children)\n    if (type && type !== 'text') {\n      parts.push(type);\n    }\n    var directText = getDirectChildText(element);\n    parts.push(directText);\n\n    return simpleHash(parts.join('.'));\n  }\n  Translator.keys.generateKey = generateKey;\n  Translator.keys.generateKey = generateKey;\n\n  // ============================================================================\n  // KEY ATTRIBUTE MANAGEMENT\n  // ============================================================================\n\n  /**\n   * Set data-xlate-key-{type} attribute\n   * @param {Element} element - The element to set attribute on\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The key value\n   */\n  function setKeyAttribute(element, type, key) {\n    if (!element || !key) {\n      return;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    element.setAttribute(ATTR_KEY_PREFIX + attrType, key);\n  }\n  Translator.attrs.setKeyAttribute = setKeyAttribute;\n  Translator.attrs.setKeyAttribute = setKeyAttribute;\n\n  /**\n   * Get data-xlate-key-{type} attribute\n   * @param {Element} element - The element to get attribute from\n   * @param {string} type - The type (text, placeholder, etc)\n   * @returns {string|null} The key value\n   */\n  function getKeyFromAttributes(element, type) {\n    if (!element) {\n      return null;\n    }\n    var attrType = type === 'text' ? 'content' : type;\n    return element.getAttribute(ATTR_KEY_PREFIX + attrType);\n  }\n  Translator.attrs.getKeyFromAttributes = getKeyFromAttributes;\n  Translator.attrs.getKeyFromAttributes = getKeyFromAttributes;\n\n  // ============================================================================\n  // TRANSLATION (Step 3: currentLang !== sourceLang)\n  // ============================================================================\n\n  /**\n   * Translate element using bundle\n   * @param {Element} element - The element to translate\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {Object} map - The translation map\n   */\n  function translateElement(element, type, map) {\n    var key = getKeyFromAttributes(element, type);\n    if (!key) {\n      return;\n    }\n\n    storeOriginalValue(element, type);\n\n    var showingTranslations = shouldShowTranslations();\n    if (!showingTranslations) {\n      var sourceValue = getSourceStringForKey(key);\n      if (type === 'text') {\n        if (typeof sourceValue === 'string' && sourceValue !== '') {\n          var originalHost = element.tagName ? element.tagName.toLowerCase() : '';\n          var sanitizedSource = sanitizeTranslationHtml(sourceValue, originalHost);\n          element.innerHTML = sanitizedSource;\n        } else {\n          restoreOriginalValue(element, type);\n        }\n        toggleAutoIndicator(element, key, false);\n      } else {\n        if (typeof sourceValue === 'string' && sourceValue !== '') {\n          element.setAttribute(type, sourceValue);\n        } else {\n          restoreOriginalValue(element, type);\n        }\n      }\n      return;\n    }\n\n    if (!map || !hasTranslation(map, key)) {\n      if (type === 'text') {\n        toggleAutoIndicator(element, key, false);\n      }\n      return;\n    }\n\n    var value = map[key];\n    if (typeof value !== 'string') {\n      return;\n    }\n\n    if (type === 'text') {\n      var hostTag = element.tagName ? element.tagName.toLowerCase() : '';\n      var sanitized = sanitizeTranslationHtml(value, hostTag);\n      element.innerHTML = sanitized;\n      toggleAutoIndicator(element, key, !isKeyReviewed(key));\n    } else {\n      element.setAttribute(type, value);\n    }\n  }\n\n  /**\n   * Restore the original/source content for an element when translations are hidden.\n   * @param {Element} element - Element to restore.\n   * @param {string} type - Attribute name or 'text'.\n   * @param {string} key - Translation key used for lookup.\n   * @returns {void}\n   */\n  function renderOriginalElement(element, type, key) {\n    if (!element || !key) {\n      return;\n    }\n\n    var sourceValue = getSourceStringForKey(key);\n    if (type === 'text') {\n      if (typeof sourceValue === 'string' && sourceValue !== '') {\n        var hostTag = element.tagName ? element.tagName.toLowerCase() : '';\n        element.innerHTML = sanitizeTranslationHtml(sourceValue, hostTag);\n      } else {\n        restoreOriginalValue(element, type);\n      }\n      toggleAutoIndicator(element, key, false);\n      return;\n    }\n\n    if (typeof sourceValue === 'string' && sourceValue !== '') {\n      element.setAttribute(type, sourceValue);\n    } else {\n      restoreOriginalValue(element, type);\n    }\n  }\n\n  /**\n   * Apply the currently active visibility mode to a single element.\n   * @param {Element} element - Target element.\n   * @param {string} type - Attribute name or 'text'.\n   * @param {Object} map - Translation map.\n   * @returns {void}\n   */\n  function applyVisibilityForElement(element, type, map) {\n    if (!element) {\n      return;\n    }\n    var key = getKeyFromAttributes(element, type);\n    if (!key) {\n      return;\n    }\n    if (shouldShowTranslations()) {\n      translateElement(element, type, map);\n      return;\n    }\n    renderOriginalElement(element, type, key);\n  }\n\n  /**\n   * Re-render every element that carries an XLATE key to match visibility mode.\n   * @param {Object} map - Translation map.\n   * @returns {void}\n   */\n  function refreshVisibleElements(map) {\n    if (typeof document === 'undefined') {\n      return;\n    }\n    var selector = KEYED_ATTRIBUTE_TYPES.map(function (attr) {\n      return '[' + ATTR_KEY_PREFIX + attr + ']';\n    }).join(',');\n    var nodes = document.querySelectorAll(selector);\n    nodes.forEach(function (node) {\n      if (node.nodeType !== 1) {\n        return;\n      }\n      if (node.hasAttribute(ATTR_KEY_PREFIX + 'content')) {\n        applyVisibilityForElement(node, 'text', map);\n      }\n      ATTRIBUTE_TYPES.forEach(function (attr) {\n        if (node.hasAttribute(ATTR_KEY_PREFIX + attr)) {\n          applyVisibilityForElement(node, attr, map);\n        }\n      });\n    });\n  }\n  /**\n   * Translate a single element using the provided translation map.\n   * @param {Element} element - Element to translate\n   * @param {string} type - Type of translation (text, placeholder, etc)\n   * @param {Object} map - Translation map keyed by generated keys\n   */\n  Translator.capture.translateElement = translateElement;\n  Translator.capture.translateElement = translateElement;\n\n  // ============================================================================\n  // CAPTURE (Step 2: currentLang === sourceLang)\n  // ============================================================================\n\n  /**\n   * Detect component from element context\n   * @param {Element} element - The element to detect component for\n   * @returns {string} Component name\n   */\n  function detectComponent(element) {\n    if (!element) {\n      return 'core';\n    }\n\n    var container = element.closest('[data-region]');\n    if (container) {\n      var region = container.getAttribute('data-region');\n      if (region) {\n        return 'region_' + region;\n      }\n    }\n\n    container = element.closest('.block');\n    if (container) {\n      var blockClass = container.className.match(/block_(\\w+)/);\n      if (blockClass) {\n        return 'block_' + blockClass[1];\n      }\n    }\n\n    if (document.body.classList.contains('path-admin')) {\n      return 'admin';\n    }\n\n    return 'core';\n  }\n  /**\n   * Save new key and source text to the backend via Ajax.\n   * @param {Element} element - Source element\n   * @param {string} text - Source text to save\n   * @param {string} type - The attribute/type (text, placeholder, ...)\n   * @param {string} key - Generated structural key\n   * @param {Object} existingMap - Optional map to avoid saving existing keys\n   */\n  Translator.capture.detectComponent = detectComponent;\n  Translator.capture.detectComponent = detectComponent;\n\n  /**\n   * Save translatable string to database\n   * @param {Element} element - The element being saved\n   * @param {string} text - The text content\n   * @param {string} type - The type (text, placeholder, etc)\n   * @param {string} key - The generated key\n   * @param {Object} existingMap - Optional bundle map to check before saving\n   */\n  function saveToDatabase(element, text, type, key, existingMap) {\n    var normalizedPayload = extractPlainText(text);\n    if (!isTranslatableText(normalizedPayload)) {\n      xlateDebug('[XLATE][Capture] Skip save - not translatable', key, describeElementContext(element));\n      return;\n    }\n\n    if (existingMap && Object.prototype.hasOwnProperty.call(existingMap, key)) {\n      var existingValue = (existingMap[key] || '').trim();\n      if (existingValue === text.trim()) {\n        xlateDebug('[XLATE][Capture] Skip save - identical text already stored', key);\n        return;\n      }\n    }\n\n    var component = detectComponent(element);\n    var dedupeKey = component + ':' + key + ':' + type;\n\n    if (detectedStrings.has(dedupeKey)) {\n      xlateDebug('[XLATE][Capture] Skip save - dedupe hit', dedupeKey);\n      return;\n    }\n    detectedStrings.add(dedupeKey);\n\n    xlateDebug('[XLATE][Capture] Saving key', key, 'component', component, 'type', type, 'snippet:', abbreviateValue(text));\n\n    // Determine page-level course id (prefer server-injected XLATE_COURSEID when present)\n    var pageCourseId = 0;\n    if (typeof window !== 'undefined' && typeof window.XLATE_COURSEID !== 'undefined') {\n      pageCourseId = window.XLATE_COURSEID;\n    } else if (typeof M !== 'undefined' && M.cfg && M.cfg.courseid) {\n      pageCourseId = M.cfg.courseid;\n    }\n\n    var curLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var sourceLang = (window.__XLATE__ && window.__XLATE__.sourceLang) ||\n      (window.__XLATE__ && window.__XLATE__.captureSourceLang) || 'en';\n    var reviewedFlag = (curLang === sourceLang) ? 1 : 0;\n\n    var payload = {\n      component: component,\n      key: key,\n      source: text,\n      lang: curLang,\n      translation: text,\n      reviewed: reviewedFlag,\n      courseid: pageCourseId,\n      context: component\n    };\n\n    xlateDebug('[XLATE][Capture] Ajax save payload', {\n      key: key,\n      component: component,\n      type: type,\n      lang: curLang,\n      courseid: pageCourseId,\n      reviewed: reviewedFlag,\n      length: text.length\n    });\n\n    Ajax.call([{\n      methodname: 'local_xlate_save_key',\n      args: payload\n    }])[0].then(function (response) {\n      if (window.__XLATE__) {\n        if (!window.__XLATE__.map) {\n          window.__XLATE__.map = {};\n        }\n        window.__XLATE__.map[key] = text;\n        if (!window.__XLATE__.reviewMap) {\n          window.__XLATE__.reviewMap = {};\n        }\n        window.__XLATE__.reviewMap[key] = 1;\n      }\n      xlateDebug('[XLATE][Capture] Save success', key, response || '');\n      return true;\n    }).catch(function (err) {\n      detectedStrings.delete(dedupeKey);\n      xlateDebug('[XLATE][Capture] Save failed', key, err && err.message ? err.message : err);\n    });\n  }\n  Translator.capture.saveToDatabase = saveToDatabase;\n  Translator.capture.saveToDatabase = saveToDatabase;\n\n  // ============================================================================\n  // ELEMENT PROCESSING (Step 1: Tag FIRST)\n  // ============================================================================\n\n  /**\n   * Check if element should be ignored\n   * @param {Element} element - The element to check\n   * @returns {boolean} True if should be ignored\n   */\n  function shouldIgnoreElement(element) {\n    if (!element || !element.tagName) {\n      return true;\n    }\n\n    var tagName = element.tagName.toLowerCase();\n    if ([\n      'script', 'style', 'meta', 'link', 'noscript', 'head'\n    ].indexOf(tagName) !== -1) {\n      return true;\n    }\n\n    // Exclude selectors from settings (window.XLATE_EXCLUDE_SELECTORS)\n    if (window.XLATE_EXCLUDE_SELECTORS && Array.isArray(window.XLATE_EXCLUDE_SELECTORS)) {\n      for (var i = 0; i < window.XLATE_EXCLUDE_SELECTORS.length; i++) {\n        var sel = window.XLATE_EXCLUDE_SELECTORS[i];\n        if (!sel) {\n          continue;\n        }\n        try {\n          if (element.matches(sel) || (element.closest && element.closest(sel))) {\n            return true;\n          }\n        } catch (e) {\n          xlateDebug('[XLATE][DEBUG] Invalid selector:', sel, e);\n        }\n      }\n    }\n\n    if (element.hasAttribute('data-xlate-ignore') || element.closest('[data-xlate-ignore]')) {\n      return true;\n    }\n\n    // Do not skip elements just because they already have key attributes;\n    // we rely on processedElements to prevent duplicate work.\n\n    // Admin paths stay blocked to avoid capturing config screens where translators do not run.\n    var currentPath = window.location.pathname || '';\n    var adminPaths = ['/admin/', '/local/xlate/', '/course/modedit.php'];\n    for (var p = 0; p < adminPaths.length; p++) {\n      if (currentPath.indexOf(adminPaths[p]) === 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  Translator.dom.shouldIgnoreElement = shouldIgnoreElement;\n\n\n  /**\n   * Collect any data-xlate-key-* attribute values from an element into a set-like object\n   * @param {Element} el - Element to inspect\n   * @param {Object} keySet - Object used as a set to store keys\n   */\n  function collectKeysFromElement(el, keySet) {\n    var attrs = el && el.attributes;\n    if (!attrs) {\n      return;\n    }\n    for (var j = 0; j < attrs.length; j++) {\n      var a = attrs[j];\n      var name = a && a.name;\n      if (name && name.indexOf(ATTR_KEY_PREFIX) === 0) {\n        var val = a.value;\n        if (val) {\n          keySet[val] = true;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether an element's readable text is entirely provided by inline children.\n   * When true we can skip capturing the parent text so each child can generate its own key.\n   * @param {Element} element - Element to inspect.\n   * @returns {boolean} True when we should defer to inline children for capture.\n   */\n  function hasTranslatableInlineChild(element) {\n    if (!element || !element.children || !element.children.length) {\n      return false;\n    }\n\n    // If the element already has direct text nodes, keep handling it normally.\n    if (getDirectChildText(element)) {\n      return false;\n    }\n\n    var childCount = element.children.length;\n    var foundEligibleChild = false;\n\n    for (var i = 0; i < childCount; i++) {\n      var child = element.children[i];\n      if (!child || !child.tagName) {\n        continue;\n      }\n      var tag = child.tagName.toLowerCase();\n\n      // Block-level children mean the parent should remain responsible for capture.\n      if (BLOCK_CHILD_TAGS.indexOf(tag) !== -1) {\n        return false;\n      }\n\n      // Decorative inline wrappers (strong/em/etc.) piggyback on the parent.\n      if (INLINE_PIGGYBACK_TAGS.indexOf(tag) !== -1) {\n        continue;\n      }\n\n      var snippet = extractPlainText(child.innerHTML || child.textContent || '');\n      if (isTranslatableText(snippet)) {\n        foundEligibleChild = true;\n      }\n    }\n\n    return foundEligibleChild;\n  }\n  /**\n   * Process a candidate value for translation or capture.\n   * @param {Element} element - Element being processed.\n   * @param {string} value - Source text or attribute value.\n   * @param {string} attrName - Attribute name ('text' for text nodes).\n   * @param {boolean} tagOnly - Whether we are in tag-only mode.\n   * @param {boolean} isCapture - Whether capture mode is active.\n   * @param {Object} map - Translation map.\n   * @returns {void}\n   */\n  function processCandidateValue(element, value, attrName, tagOnly, isCapture, map) {\n    if (!value) {\n      if (isCapture) {\n        xlateDebug('[XLATE][Capture] Empty value ignoring', attrName, describeElementContext(element));\n      }\n      return;\n    }\n\n    var existingKey = getKeyFromAttributes(element, attrName);\n    var detectionValue = extractPlainText(value);\n    if (!existingKey && !isTranslatableText(detectionValue)) {\n      if (isCapture) {\n        xlateDebug(\n          '[XLATE][Capture] Non-translatable value skipped',\n          attrName,\n          describeElementContext(element),\n          'snippet:',\n          abbreviateValue(value)\n        );\n      }\n      return;\n    }\n    var key = existingKey || generateKey(element, value, attrName);\n    if (!key) {\n      if (isCapture) {\n        xlateDebug(\n          '[XLATE][Capture] Failed to generate key',\n          attrName,\n          describeElementContext(element),\n          'snippet:',\n          abbreviateValue(value)\n        );\n      }\n      return;\n    }\n\n    if (!existingKey) {\n      setKeyAttribute(element, attrName, key);\n    }\n\n    if (tagOnly) {\n      if (isCapture) {\n        xlateDebug('[XLATE][Capture] Tag-only pass recorded key', key, 'for', attrName, describeElementContext(element));\n      }\n      return;\n    }\n\n    if (isCapture) {\n      saveToDatabase(element, value, attrName, key, map);\n      return;\n    }\n\n    var showingTranslations = shouldShowTranslations();\n    if (!showingTranslations) {\n      renderOriginalElement(element, attrName, key);\n      return;\n    }\n\n    if (!map) {\n      return;\n    }\n\n    if (hasTranslation(map, key)) {\n      translateElement(element, attrName, map);\n      return;\n    }\n\n    queueMissingTranslation(key);\n  }\n\n  /**\n   * Process a single DOM element: tag, then optionally save or translate.\n   * @param {Element} element - Element to process\n   * @param {Object} map - Translation map\n   * @param {boolean} tagOnly - When true, only add key attributes\n   */\n  function processElement(element, map, tagOnly) {\n    if (shouldIgnoreElement(element) || processedElements.has(element)) {\n      return;\n    }\n    var tagName = element.tagName ? element.tagName.toLowerCase() : '';\n    if (\n      element.parentElement &&\n      element.parentElement.hasAttribute(ATTR_KEY_PREFIX + 'content') &&\n      INLINE_PIGGYBACK_TAGS.indexOf(tagName) !== -1\n    ) {\n      if (window.__XLATE__ && window.__XLATE__.isCapture) {\n        xlateDebug('[XLATE][Capture] Skipping inline child inside keyed parent', describeElementContext(element));\n      }\n      processedElements.add(element);\n      return;\n    }\n    processedElements.add(element);\n\n    var currentLang = (window.__XLATE__ && window.__XLATE__.lang) || M.cfg.language || 'en';\n    var sourceLang = (window.__XLATE__ && window.__XLATE__.sourceLang) ||\n      (window.__XLATE__ && window.__XLATE__.captureSourceLang) || 'en';\n    var isCapture = (currentLang === sourceLang);\n\n    var skipTextCapture = false;\n    if (element.querySelector && element.querySelector(BLOCK_CHILD_SELECTOR)) {\n      // Only skip when the element has no direct text nodes of its own; this keeps\n      // wrappers that mix inline markup (e.g., <strong>) with paragraph text eligible\n      // for capture while still avoiding structural containers like cards/lists.\n      var directText = getDirectChildText(element);\n      if (!directText) {\n        skipTextCapture = true;\n        if (window.__XLATE__ && window.__XLATE__.isCapture) {\n          xlateDebug('[XLATE][Capture] Skipping container without direct text', describeElementContext(element));\n        }\n      }\n    }\n\n    if (!skipTextCapture && hasTranslatableInlineChild(element)) {\n      skipTextCapture = true;\n      if (window.__XLATE__ && window.__XLATE__.isCapture) {\n        xlateDebug('[XLATE][Capture] Deferring to inline child for text capture', describeElementContext(element));\n      }\n    }\n\n    if (!skipTextCapture) {\n      var sourceText = getElementSourcePayload(element);\n      processCandidateValue(element, sourceText, 'text', tagOnly, isCapture, map);\n    }\n\n    // Process attributes\n    ATTRIBUTE_TYPES.forEach(function (attr) {\n      if (!element.hasAttribute(attr)) {\n        return;\n      }\n      var value = element.getAttribute(attr).trim();\n      processCandidateValue(element, value, attr, tagOnly, isCapture, map);\n    });\n  }\n  Translator.dom.collectKeysFromElement = collectKeysFromElement;\n\n  /**\n   * Debounced trigger that batches pending keys and requests translations.\n   * @returns {void}\n   */\n  function scheduleMissingFetch() {\n    if (missingFetchTimer !== null) {\n      return;\n    }\n    missingFetchTimer = window.setTimeout(function () {\n      missingFetchTimer = null;\n      if (!pendingTranslationKeys || pendingTranslationKeys.size === 0) {\n        return;\n      }\n      var keys = [];\n      pendingTranslationKeys.forEach(function (k) {\n        keys.push(k);\n      });\n      pendingTranslationKeys.clear();\n      fetchMissingTranslations(keys);\n    }, 200);\n  }\n\n  /**\n   * Mark keys as requested to avoid duplicate fetching.\n   * @param {Array<string>} keys - Keys to record.\n   * @returns {void}\n   */\n  function markKeysAsRequested(keys) {\n    keys.forEach(function (k) {\n      requestedTranslationKeys.add(k);\n    });\n  }\n\n  /**\n   * Remove keys from requested set after a failed fetch.\n   * @param {Array<string>} keys - Keys to remove.\n   * @returns {void}\n   */\n  function unmarkRequestedKeys(keys) {\n    keys.forEach(function (k) {\n      requestedTranslationKeys.delete(k);\n    });\n  }\n\n  /**\n   * Merge new translations into the provided map.\n   * @param {Object} map - Existing translation map.\n   * @param {Object} translations - Incoming translations.\n   * @returns {boolean} True when at least one entry changed.\n   */\n  function mergeTranslationsIntoMap(map, translations) {\n    var updated = false;\n    Object.keys(translations).forEach(function (k) {\n      var value = translations[k];\n      if (!Object.prototype.hasOwnProperty.call(map, k) || map[k] !== value) {\n        map[k] = value;\n        updated = true;\n      }\n    });\n    return updated;\n  }\n\n  /**\n   * Ensure the global review map exists and merge incoming flags.\n   * @param {Object|null} reviewUpdates - Incoming review flags.\n   * @returns {boolean} True when any review flag changed.\n   */\n  function applyReviewUpdates(reviewUpdates) {\n    if (!reviewUpdates || typeof reviewUpdates !== 'object') {\n      return false;\n    }\n\n    if (!window.__XLATE__.reviewMap) {\n      window.__XLATE__.reviewMap = {};\n    }\n\n    var reviewChanged = false;\n    Object.keys(reviewUpdates).forEach(function (k) {\n      var incoming = reviewUpdates[k];\n      if (window.__XLATE__.reviewMap[k] !== incoming) {\n        reviewChanged = true;\n      }\n      window.__XLATE__.reviewMap[k] = incoming;\n    });\n\n    return reviewChanged;\n  }\n\n  /**\n   * Persist the latest translations, source strings, and review map to cache.\n   * @param {Object} translations - Newly received translations.\n   * @param {Object|null} [sources] - Optional source string updates to persist.\n   * @returns {void}\n   */\n  function syncCacheWithLatest(translations, sources) {\n    if (!window.__XLATE__.cacheKey) {\n      return;\n    }\n\n    try {\n      var cached = localStorage.getItem(window.__XLATE__.cacheKey);\n      var cachedPayload = cached ? JSON.parse(cached) : null;\n      var cachedTranslations = {};\n      var cachedReviewed = {};\n      var cachedSources = {};\n\n      if (cachedPayload && typeof cachedPayload === 'object') {\n        if (cachedPayload.translations && typeof cachedPayload.translations === 'object') {\n          cachedTranslations = cachedPayload.translations;\n          cachedReviewed = cachedPayload.reviewed || {};\n          cachedSources = cachedPayload.sources || cachedPayload.sourceStrings || {};\n        } else if (!Array.isArray(cachedPayload)) {\n          cachedTranslations = cachedPayload;\n        }\n      }\n\n      Object.keys(translations || {}).forEach(function (k) {\n        cachedTranslations[k] = translations[k];\n      });\n\n      var reviewMap = window.__XLATE__.reviewMap || {};\n      Object.keys(reviewMap).forEach(function (k) {\n        cachedReviewed[k] = reviewMap[k];\n      });\n\n      if (sources && typeof sources === 'object') {\n        Object.keys(sources).forEach(function (k) {\n          cachedSources[k] = sources[k];\n        });\n      }\n\n      localStorage.setItem(window.__XLATE__.cacheKey, JSON.stringify({\n        translations: cachedTranslations,\n        reviewed: cachedReviewed,\n        sources: cachedSources\n      }));\n    } catch (e) {\n      // Ignore cache sync errors.\n    }\n  }\n\n  /**\n   * Request translations for keys discovered after the initial bundle load.\n   * @param {Array<string>} keys - Structural keys requiring translations.\n   * @returns {void}\n   */\n  function fetchMissingTranslations(keys) {\n    if (!keys || !keys.length) {\n      return;\n    }\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n\n    var bundleUrl = window.__XLATE__.bundleUrl || '';\n    if (!bundleUrl) {\n      return;\n    }\n\n    fetch(bundleUrl, {\n      method: 'POST',\n      credentials: 'same-origin',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ keys: keys })\n    })\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (data) {\n        var map = window.__XLATE__.map || {};\n        var translations = (data && data.translations) ? data.translations : data;\n        if (!translations || typeof translations !== 'object') {\n          markKeysAsRequested(keys);\n          return null;\n        }\n\n        var sourceUpdates = (data && data.sources && typeof data.sources === 'object') ? data.sources : null;\n        if (sourceUpdates) {\n          if (!window.__XLATE__.sourceStrings || typeof window.__XLATE__.sourceStrings !== 'object') {\n            window.__XLATE__.sourceStrings = {};\n          }\n          Object.keys(sourceUpdates).forEach(function (k) {\n            window.__XLATE__.sourceStrings[k] = sourceUpdates[k];\n          });\n        }\n\n        var updated = mergeTranslationsIntoMap(map, translations);\n        var reviewChanged = applyReviewUpdates(data && data.reviewed ? data.reviewed : null);\n\n        if (updated || reviewChanged) {\n          window.__XLATE__.map = map;\n          syncCacheWithLatest(translations, sourceUpdates);\n\n          processedElements = new WeakSet();\n          walk(document.body, map, false);\n        }\n\n        markKeysAsRequested(keys);\n        return null;\n      })\n      .catch(function (err) {\n        unmarkRequestedKeys(keys);\n        xlateDebug('[XLATE] Missing translation fetch failed', err);\n        return null;\n      });\n  }\n\n  /**\n   * Queue a translation key for deferred fetching if it is not already pending.\n   * @param {string} key - Structural key needing translation.\n   * @returns {void}\n   */\n  function queueMissingTranslation(key) {\n    if (!key || pendingTranslationKeys.has(key) || requestedTranslationKeys.has(key)) {\n      return;\n    }\n    if (!window.__XLATE__ || window.__XLATE__.isCapture) {\n      return;\n    }\n    pendingTranslationKeys.add(key);\n    scheduleMissingFetch();\n  }\n  Translator.dom.processElement = processElement;\n\n  // ============================================================================\n  // DOM WALKING\n  // ============================================================================\n\n  /**\n   * Walk DOM and process elements\n   * @param {Element} root - Root element to start from\n   * @param {Object} map - The translation map\n   * @param {boolean} tagOnly - When true, only tag keys without saving/translating\n   */\n  function walk(root, map, tagOnly) {\n    if (!root) {\n      return;\n    }\n\n    // If capture selectors are set, only walk those areas\n    var captureSelectors = (window.XLATE_CAPTURE_SELECTORS &&\n      Array.isArray(window.XLATE_CAPTURE_SELECTORS) &&\n      window.XLATE_CAPTURE_SELECTORS.length)\n      ? window.XLATE_CAPTURE_SELECTORS : null;\n\n    var roots = [];\n    if (captureSelectors) {\n      captureSelectors.forEach(function (sel) {\n        try {\n          var found = document.querySelectorAll(sel);\n          for (var i = 0; i < found.length; i++) {\n            roots.push(found[i]);\n          }\n        } catch (e) { /* Ignore invalid selectors */ }\n      });\n      if (!roots.length) {\n        roots = [root]; // Fallback to body\n      }\n    } else {\n      roots = [root];\n    }\n\n    roots.forEach(function (scanRoot) {\n      var stack = [scanRoot];\n      while (stack.length) {\n        var el = stack.pop();\n        if (el.nodeType === 1) {\n          // If this element should be ignored (exclusion zone), skip its subtree\n          if (shouldIgnoreElement(el)) {\n            continue;\n          }\n          processElement(el, map, tagOnly);\n          var children = el.children || [];\n          for (var i = 0; i < children.length; i++) {\n            stack.push(children[i]);\n          }\n        }\n      }\n    });\n  }\n  Translator.dom.walk = walk;\n  Translator.dom.walk = walk;\n\n  /**\n   * Run translator\n   * @param {Object<string,string>} map Translation map keyed by structural hash.\n   * @returns {void}\n   */\n  function run(map) {\n    try {\n      walk(document.body, map || {});\n\n      // Fallback: periodic refreshes to catch late-injected content\n      setTimeout(function () {\n        walk(document.body, map || {});\n      }, 1000);\n      setTimeout(function () {\n        walk(document.body, map || {});\n      }, 3000);\n      setTimeout(function () {\n        walk(document.body, map || {});\n      }, 6000);\n\n      var mo = new MutationObserver(function (muts) {\n        muts.forEach(function (mutation) {\n          Array.prototype.slice.call(mutation.addedNodes || []).forEach(function (node) {\n            if (node.nodeType === 1) {\n              walk(node, map || {});\n            }\n          });\n        });\n      });\n      mo.observe(document.body, { childList: true, subtree: true });\n\n      if (typeof window.addEventListener === 'function') {\n        ['focus', 'click', 'scroll'].forEach(function (eventType) {\n          document.addEventListener(eventType, function () {\n            var now = Date.now();\n            if (now - lastProcessTime > processThrottle) {\n              lastProcessTime = now;\n              setTimeout(function () {\n                walk(document.body, map || {});\n              }, 100);\n            }\n          }, true);\n        });\n      }\n    } finally {\n      document.documentElement.classList.remove('xlate-loading');\n    }\n  }\n  Translator.api.run = run;\n  Translator.api.setTranslationVisibility = setTranslationVisibility;\n\n  /**\n   * Get source value for an element based on the key attribute type.\n   * @param {Element} el - Element to inspect\n   * @param {string} typename - Attribute type (content for text)\n   * @returns {string} Source value or empty string\n   */\n  function getSourceForElementAttr(el, typename) {\n    if (!el) {\n      return '';\n    }\n    if (typename === 'content') {\n      return getElementSourcePayload(el);\n    }\n    try {\n      return el.getAttribute(typename) || '';\n    } catch (e) {\n      return '';\n    }\n  }\n\n  /**\n   * Collect key set and first-seen details (component + source) for keys under root.\n   * @param {Element} root - Root to scan\n   * @returns {Object} {keySet: {}, keyDetails: {}}\n   */\n  function collectKeySetAndDetails(root) {\n    var keySet = {};\n    var keyDetails = {};\n    var all = (root && root.querySelectorAll) ? root.querySelectorAll('*') : [];\n    for (var i = 0; i < all.length; i++) {\n      var el = all[i];\n      collectKeysFromElement(el, keySet);\n      var attrs = el && el.attributes;\n      if (!attrs) {\n        continue;\n      }\n      for (var j = 0; j < attrs.length; j++) {\n        var attrname = attrs[j] && attrs[j].name;\n        if (!attrname || attrname.indexOf(ATTR_KEY_PREFIX) !== 0) {\n          continue;\n        }\n        var aval = attrs[j].value;\n        if (!aval) {\n          continue;\n        }\n        if (keyDetails[aval]) {\n          continue;\n        }\n        var typename = attrname.substring(ATTR_KEY_PREFIX.length);\n        var src = getSourceForElementAttr(el, typename);\n        keyDetails[aval] = {\n          component: detectComponent(el),\n          source: src\n        };\n      }\n    }\n    return { keySet: keySet, keyDetails: keyDetails };\n  }\n\n  /**\n   * Create the base XLATE state object from configuration.\n   * @param {TranslatorConfig} config - Translator configuration.\n   * @returns {Object} Base state object.\n   */\n  function createXlateState(config) {\n    var resolvedSourceLang = config.sourceLang || config.captureSourceLang || config.lang || 'en';\n    var targetLangs = Array.isArray(config.targetLangs) ? config.targetLangs : [];\n    var enabledLangs = Array.isArray(config.enabledLangs) ? config.enabledLangs : [];\n\n    var state = {\n      lang: config.lang,\n      sourceLang: resolvedSourceLang,\n      captureSourceLang: config.captureSourceLang || resolvedSourceLang,\n      targetLangs: targetLangs,\n      enabledLangs: enabledLangs,\n      map: {},\n      sourceMap: {},\n      sourceStrings: {},\n      reviewMap: {},\n      bundleUrl: config.bundleurl || '',\n      version: config.version || '',\n      cacheKey: '',\n      inlineIndicator: !!config.showInlineIndicators\n    };\n\n    state.isCapture = (config.lang === state.captureSourceLang);\n    state.isTargetLang = !state.targetLangs.length || state.targetLangs.indexOf(config.lang) !== -1;\n    return state;\n  }\n\n  /**\n   * Resolve the active course id exposed to the page, if any.\n   * @returns {number|null} Course id or null when unavailable.\n   */\n  function resolveCourseId() {\n    if (typeof window !== 'undefined' && typeof window.XLATE_COURSEID !== 'undefined') {\n      return window.XLATE_COURSEID;\n    }\n\n    if (typeof M !== 'undefined' && M.cfg && M.cfg.courseid) {\n      return M.cfg.courseid;\n    }\n\n    return null;\n  }\n\n  /**\n   * Associate keys with a course when the backend provides association metadata.\n   * @param {Array<string>} keys - Keys collected from DOM.\n   * @param {Object} keyDetails - Per-key detail map.\n   * @param {Object} associations - Associations returned from bundle.\n   * @param {number|null} courseId - Course id when available.\n   * @returns {void}\n   */\n  function associateKeysWithCourse(keys, keyDetails, associations, courseId) {\n    if (!courseId || !associations || typeof associations !== 'object') {\n      return;\n    }\n\n    var toAssociate = [];\n    for (var ti = 0; ti < keys.length; ti++) {\n      var key = keys[ti];\n      if (!associations[key]) {\n        var detail = keyDetails[key] || null;\n        if (detail) {\n          toAssociate.push({\n            component: detail.component,\n            key: key,\n            source: detail.source || ''\n          });\n        }\n      }\n    }\n\n    if (!toAssociate.length) {\n      return;\n    }\n\n    xlateDebug('[XLATE] Associating', toAssociate.length, 'keys with course', courseId);\n    try {\n      Ajax.call([{\n        methodname: 'local_xlate_associate_keys',\n        args: {\n          keys: toAssociate,\n          courseid: courseId,\n          context: ''\n        }\n      }]);\n    } catch (e) {\n      xlateDebug('[XLATE] Bulk-associate exception', e);\n    }\n  }\n\n  /**\n   * Hydrate cached translations for translation mode.\n   * @param {string} cacheKey - Cache key identifier.\n   * @returns {{translations:Object, reviewed:Object}|null} Cached payload when available.\n   */\n  function readCachedBundle(cacheKey) {\n    if (!cacheKey) {\n      return null;\n    }\n\n    try {\n      var cached = localStorage.getItem(cacheKey);\n      if (!cached) {\n        return null;\n      }\n      var payload = JSON.parse(cached);\n      if (!payload || typeof payload !== 'object') {\n        return null;\n      }\n\n      if (payload.translations && typeof payload.translations === 'object') {\n        return {\n          translations: payload.translations,\n          reviewed: payload.reviewed || {},\n          sources: payload.sources || payload.sourceStrings || {}\n        };\n      }\n\n      if (!Array.isArray(payload)) {\n        return {\n          translations: payload,\n          reviewed: {},\n          sources: {}\n        };\n      }\n    } catch (e) {\n      return null;\n    }\n\n    return null;\n  }\n\n  /**\n   * Handle capture-mode initialization logic.\n   * @param {TranslatorConfig} config - Translator configuration.\n   * @param {number|null} courseId - Active course id, if any.\n   * @returns {void}\n   */\n  function initCaptureMode(config, courseId) {\n    xlateDebug('[XLATE] Capture mode - starting tag-only pass');\n    processedElements = new WeakSet();\n    walk(document.body, {}, true);\n\n    var collected = collectKeySetAndDetails(document);\n    var keySetCap = collected.keySet;\n    var keyDetails = collected.keyDetails;\n    var keysCap = Object.keys(keySetCap);\n\n    xlateDebug('[XLATE] Collected', keysCap.length, 'keys from DOM');\n\n    if (!keysCap.length) {\n      xlateDebug('[XLATE] No keys found, skipping bundle fetch');\n      run({});\n      return;\n    }\n\n    xlateDebug('[XLATE] Fetching bundle to check existing keys...');\n    fetch(config.bundleurl, {\n      method: 'POST',\n      credentials: 'same-origin',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ keys: keysCap })\n    })\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (map) {\n        var translations = (map && map.translations) ? map.translations : map;\n        var sourceMap = (map && map.sourceMap) ? map.sourceMap : {};\n        var reviewMap = (map && map.reviewed && typeof map.reviewed === 'object') ? map.reviewed : {};\n        var sourceStrings = (map && map.sources && typeof map.sources === 'object') ? map.sources : {};\n        var associations = (map && map.associations) ? map.associations : {};\n        if (!translations || typeof translations !== 'object') {\n          translations = {};\n        }\n        window.__XLATE__.map = translations;\n        window.__XLATE__.sourceMap = sourceMap;\n        window.__XLATE__.sourceStrings = sourceStrings;\n        window.__XLATE__.reviewMap = reviewMap;\n\n        var existingCount = Object.keys(translations).length;\n        xlateDebug('[XLATE] Bundle returned', existingCount, 'existing translations');\n\n        associateKeysWithCourse(keysCap, keyDetails, associations, courseId);\n\n        processedElements = new WeakSet();\n        walk(document.body, translations, false);\n        run(translations);\n        return true;\n      })\n      .catch(function (err) {\n        xlateDebug('[XLATE] Bundle fetch failed:', err);\n        processedElements = new WeakSet();\n        walk(document.body, {}, false);\n        run({});\n      });\n  }\n\n  /**\n   * Handle translation-mode initialization logic.\n   * @param {TranslatorConfig} config - Translator configuration.\n   * @returns {void}\n   */\n  function initTranslationMode(config) {\n    xlateDebug('[XLATE] Translation mode - starting tag-only pass');\n    try {\n      processedElements = new WeakSet();\n      walk(document.body, {}, true);\n\n      var keySet = {};\n      var all = document.querySelectorAll('*');\n      for (var i = 0; i < all.length; i++) {\n        collectKeysFromElement(all[i], keySet);\n      }\n      var keys = Object.keys(keySet);\n\n      if (!keys.length) {\n        run({});\n        return;\n      }\n\n      var cacheKey = 'xlate:' + config.lang + ':' + config.version + ':keys:' + keys.length;\n      window.__XLATE__.cacheKey = cacheKey;\n\n      var cachedPayload = readCachedBundle(cacheKey);\n      if (cachedPayload) {\n        window.__XLATE__.map = cachedPayload.translations;\n        window.__XLATE__.reviewMap = cachedPayload.reviewed;\n        window.__XLATE__.sourceStrings = cachedPayload.sources || {};\n        processedElements = new WeakSet();\n        run(cachedPayload.translations);\n      }\n\n      fetch(config.bundleurl, {\n        method: 'POST',\n        credentials: 'same-origin',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ keys: keys })\n      })\n        .then(function (response) {\n          return response.json();\n        })\n        .then(function (map) {\n          var translations = (map && map.translations) ? map.translations : map;\n          var reviewMap = (map && map.reviewed && typeof map.reviewed === 'object') ? map.reviewed : {};\n          var sourceStrings = (map && map.sources && typeof map.sources === 'object') ? map.sources : {};\n          if (!translations || typeof translations !== 'object') {\n            translations = {};\n          }\n          try {\n            localStorage.setItem(cacheKey, JSON.stringify({\n              translations: translations,\n              reviewed: reviewMap,\n              sources: sourceStrings\n            }));\n          } catch (e) {\n            // Ignore\n          }\n          window.__XLATE__.map = translations;\n          window.__XLATE__.reviewMap = reviewMap;\n          window.__XLATE__.sourceStrings = sourceStrings;\n          processedElements = new WeakSet();\n          run(translations);\n          return true;\n        })\n        .catch(function () {\n          run({});\n        });\n    } catch (err) {\n      run({});\n    }\n  }\n\n  /**\n   * @typedef {Object} TranslatorConfig\n   * @property {string} lang Current page language code.\n  * @property {string} sourceLang Base source language for the request (course or site default).\n  * @property {Array<string>} [targetLangs] Target languages configured for this course.\n  * @property {Array<string>} [enabledLangs] Enabled languages available site-wide.\n  * @property {string} [captureSourceLang] Course-specific source language for capture (falls back to sourceLang if not set).\n   * @property {string} bundleurl REST endpoint returning translation bundles.\n   * @property {string} version Bundle version hash used for cache busting.\n   * @property {boolean} isEditing True when Moodle editing mode is active.\n   */\n\n  /**\n   * Initialize translator\n   * @param {TranslatorConfig} config Configuration object injected server-side.\n   */\n  function init(config) {\n    document.documentElement.classList.add('xlate-loading');\n\n    // If editing mode is enabled, skip all capture/tagging logic\n    if (config.isEditing) {\n      xlateDebug('[XLATE] Edit mode detected (isEditing=true): skipping translation/capture logic.');\n      document.documentElement.classList.remove('xlate-loading');\n      return;\n    }\n\n    window.__XLATE__ = createXlateState(config);\n    window.__XLATE__.showTranslations = true;\n    window.__XLATE__.setTranslationVisibility = setTranslationVisibility;\n    window.__XLATE__.toggleTranslations = function () {\n      setTranslationVisibility();\n    };\n    window.__XLATE__.canToggleTranslations = !window.__XLATE__.isCapture && window.__XLATE__.isTargetLang !== false;\n    if (typeof document !== 'undefined' && document.documentElement) {\n      document.documentElement.classList.remove('xlate-original-visible');\n    }\n    dispatchXlateEvent('xlate:ready', {\n      isTargetLang: window.__XLATE__.isTargetLang,\n      isCapture: window.__XLATE__.isCapture\n    });\n    dispatchXlateEvent('xlate:visibilitychange', { visible: shouldShowTranslations() });\n\n    var courseId = resolveCourseId();\n    xlateDebug('[XLATE] Initializing:', {\n      currentLang: config.lang,\n      sourceLang: window.__XLATE__.sourceLang,\n      captureSourceLang: window.__XLATE__.captureSourceLang,\n      targetLangs: window.__XLATE__.targetLangs,\n      isCapture: window.__XLATE__.isCapture,\n      isTargetLang: window.__XLATE__.isTargetLang,\n      courseId: courseId\n    });\n\n    if (window.__XLATE__.isCapture) {\n      initCaptureMode(config, courseId);\n      return;\n    }\n\n    if (!window.__XLATE__.isTargetLang) {\n      xlateDebug('[XLATE] Current language is not a configured target; skipping translation runtime.');\n      document.documentElement.classList.remove('xlate-loading');\n      return;\n    }\n\n    initTranslationMode(config);\n  }\n  Translator.api.init = init;\n\n  Translator.run = run;\n  Translator.init = init;\n\n  return Translator;\n});"],"names":["define","Ajax","ATTRIBUTE_TYPES","KEYED_ATTRIBUTE_TYPES","concat","detectedStrings","Set","processedElements","WeakSet","lastProcessTime","pendingTranslationKeys","requestedTranslationKeys","missingFetchTimer","indicatorStylesAdded","BLOCK_CHILD_TAGS","BLOCK_CHILD_SELECTOR","join","window","XLATE_LAST_TOGGLE_REQUEST","XLATE_LAST_TOGGLE_APPLIED","ALLOWED_INLINE_TAGS","INLINE_PIGGYBACK_TAGS","Translator","sanitizeNode","root","childNodes","Array","prototype","slice","call","forEach","child","nodeType","tag","tagName","toLowerCase","Object","hasOwnProperty","allowedAttrs","element","attributes","attr","name","indexOf","url","trimmed","trim","lower","test","isSafeUrl","value","removeAttribute","setAttribute","parentNode","parent","firstChild","insertBefore","removeChild","unwrapElement","sanitizeTranslationHtml","targetTag","container","document","createElement","innerHTML","length","unwrap","appendChild","getDirectChildText","text","i","node","textContent","extractPlainText","innerText","getElementSourcePayload","raw","sanitized","__XLATE__","isCapture","xlateDebug","describeElementContext","abbreviateValue","fallbackPlain","direct","XLATE_DEBUG","console","debug","apply","arguments","log","id","classSuffix","className","classes","split","filter","Boolean","substring","collectContextClasses","classList","blacklist","cls","push","collectDataAttributes","dataAttrs","simpleHash","str","h1","h2","c","charCodeAt","Math","imul","k","s","toString","isTranslatableText","match","hasTranslation","map","key","restoreOriginalValue","type","dataAttr","hasAttribute","original","getAttribute","shouldShowTranslations","showTranslations","getSourceStringForKey","sourceStrings","dispatchXlateEvent","detail","dispatchEvent","event","payload","CustomEvent","err","createEvent","initCustomEvent","applyVisibilityState","newValue","documentElement","toggle","selector","querySelectorAll","ATTR_KEY_PREFIX","applyVisibilityForElement","refreshVisibleElements","visible","setTranslationVisibility","request","source","requestedVisibility","time","Date","now","XLATE_TOGGLE_LOG","at","requested","priorState","result","keys","Promise","resolve","store","missing","isArray","sourceFetchPromise","sourceUrl","bundleUrl","bundleurl","URL","location","origin","anchor","href","sourceLang","captureSourceLang","lang","searchParams","set","fetch","method","credentials","headers","body","JSON","stringify","then","response","json","providedSources","sources","translations","catch","finally","ensureSourceStrings","toggleAutoIndicator","show","inlineIndicator","__xlateIndicator","remove","style","head","ensureIndicatorStyles","indicator","generateKey","parts","parentElement","parentClasses","parentData","directText","setKeyAttribute","attrType","getKeyFromAttributes","translateElement","storeOriginalValue","reviewMap","flag","isKeyReviewed","sourceValue","sanitizedSource","renderOriginalElement","hostTag","detectComponent","closest","region","blockClass","contains","saveToDatabase","existingMap","component","dedupeKey","has","add","pageCourseId","XLATE_COURSEID","M","cfg","courseid","curLang","language","reviewedFlag","translation","reviewed","context","methodname","args","delete","message","shouldIgnoreElement","XLATE_EXCLUDE_SELECTORS","sel","matches","e","currentPath","pathname","adminPaths","p","collectKeysFromElement","el","keySet","attrs","j","a","val","processCandidateValue","attrName","tagOnly","existingKey","detectionValue","setTimeout","size","clear","data","markKeysAsRequested","sourceUpdates","updated","mergeTranslationsIntoMap","reviewChanged","reviewUpdates","incoming","applyReviewUpdates","cacheKey","cached","localStorage","getItem","cachedPayload","parse","cachedTranslations","cachedReviewed","cachedSources","setItem","syncCacheWithLatest","walk","unmarkRequestedKeys","fetchMissingTranslations","scheduleMissingFetch","queueMissingTranslation","processElement","skipTextCapture","querySelector","children","childCount","foundEligibleChild","hasTranslatableInlineChild","sourceText","captureSelectors","XLATE_CAPTURE_SELECTORS","roots","found","scanRoot","stack","pop","run","MutationObserver","muts","mutation","addedNodes","observe","childList","subtree","addEventListener","eventType","getSourceForElementAttr","typename","initCaptureMode","config","courseId","collected","keyDetails","all","attrname","aval","src","collectKeySetAndDetails","keySetCap","keysCap","sourceMap","associations","toAssociate","ti","associateKeysWithCourse","initTranslationMode","version","readCachedBundle","init","isEditing","resolvedSourceLang","targetLangs","enabledLangs","state","showInlineIndicators","isTargetLang","createXlateState","toggleTranslations","canToggleTranslations","currentLang","utils","capture","dom","api"],"mappings":"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"}